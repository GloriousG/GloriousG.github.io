{
  "posts": [
    {
      "content": "# Leave a comment and share your view :)\n# 欢迎留言分享你的观点 :)\n\n![Konata](https://user-images.githubusercontent.com/12698567/40700912-4b2c5824-640e-11e8-9694-7a212f66dc7e.jpg)",
      "data": {
        "title": "留言板",
        "date": "2019-06-01 20:10:08",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "bbs"
    },
    {
      "content": "### 2019\n\n<input type='checkbox' checked>[ 《设计模式》](https://book.douban.com/subject/1052241/) | 才知道原来有些模式工作中就用到了🤣马马虎虎看吧，主要是各个模式的类图，不懂的可以结合网上的说明。入门不大推荐这本书，可以看head first系列。\n\n<input type='checkbox' checked>[ 《Redis实战》](https://book.douban.com/subject/26612779/) | 18年拖到现在书=。=真的很实战，例子很巧妙，到后面的例子有些难读，常常看了后面代码忘了前面干了啥。。。\n\n### 2018\n\n<input type='checkbox' checked>[ 《图解HTTP》](https://book.douban.com/subject/25863515/) | 你以为你会HTTP系列。很多首部字段都是重新认知。第四章到第九章是重点，其它章节偏科普。\n\n<input type='checkbox' checked>[ 《人之彼岸》](https://book.douban.com/subject/27180217/) | 用人工智能的可能发展方向分别写了一些短篇，作为消遣阅读还是不错的。\n\n<input type='checkbox' checked>[ 《Effective Python》](https://book.douban.com/subject/26312313/) | Great book! Especially when you encounter the same problem.\n\n<input type='checkbox' checked>《聪明投资者的第一本金融学常识书》 | 在多看上买的，真心偏概念，后期有些干货。感觉概念这种东西，还是一边实际接触，一边了解比较好，这样直接提出概念，我觉得很难消化，而且语言也不有趣。\n\n<input type='checkbox' checked>[《万历十五年》](https://book.douban.com/subject/1041482/) | 高中毕业后觉得大学该读的书之一，当时纯粹是觉得大学了，该好好学学这些“杂书”。本书从多个历史人物角度，展示了整个朝代存在的问题，特性。代入到历史情境，我觉得事情很是复杂= =如何上下一心？环境不可改的情况下，如何才能实现自己的目的？人性中的阴和阳。\n\n<input type='checkbox' checked>《小花的投资魔法书》 | 理财入门，通俗易懂，很不错，不仅讲了投资，还讲了投资的心态，学习的方法。最初有些概念不了解，云里雾里，直到我买了点基金= =\n\n<input type='checkbox' checked>[《大型分布式网站架构设计与实践》](https://book.douban.com/subject/25972633/) | 蛮推荐的说。介绍了很多姿势，比如：服务负载均衡、消息系统、持久化存储、web安全、性能优化、数据分析。发现这段时间实习下来有些都略有接触，所以觉得本书实用性还是蛮高的。（PS：本来打算17年一定要读完，结果拖到现在，2333，不过总算是拜读完了）\n\n<input type='checkbox' checked>[《QBQ问题背后的问题》](https://book.douban.com/subject/1225038/) | 部门内传阅看的。强调个人责任，转换问题方向“why”->“how”。让我想起了《不抱怨的世界》。此类书籍重要的还是牢记，否则都是空谈。\n\n### 2017\n\n<input type='checkbox' checked>[《Python学习手册（第4版）》](https://book.douban.com/subject/6049132/) | 大抵是些语法、语言特性上的收获，高级话题部分比较费力。翻译一般。不推荐初学者靠这个入门。\n\n<input type='checkbox' checked>[《Web Scraping with Python》](https://book.douban.com/subject/26284925/) | 数据清洗、动态抓取、图像识别、防爬策略都是本书不错的章节。\n\n<input type='checkbox' checked>[《嫌疑犯X的献身》](https://book.douban.com/subject/3211779/) | 看到中期有种不想看的念头，觉得一切水到渠成，警方总能恰巧抓住线索，太没意思。后期的反转还是比较惊艳，最后的结局不是很喜欢，但也想不到可以替代的结局。\n\n<input type='checkbox' checked>[《用Python写网络爬虫》](https://book.douban.com/subject/26869992/) | 篇幅不大，较为基础入门，能有个大概的轮廓，代码比较分散，所以理解起来有些费力。验证码部分感觉很惊艳。\n\n<input type='checkbox' checked>[《Python for Informatics》](https://github.com/GooZy/BookList/blob/master/2017/Python%20for%20Informatics.pdf) | 前十二章是数据处理所需知道的基础，专门拿来练习英文阅读了XD。到十五章数据可视化感觉比较吃力= =。总得感觉这本书还是不错哒，回忆基础看前十二章就行啦。此书是基于py2，py3版本见[链接](http://www.py4e.com/book.php)。\n\n<input type='checkbox' checked>[《快乐Linux命令行》](https://github.com/GooZy/BookList/blob/master/2017/%E5%BF%AB%E4%B9%90Linux%E5%91%BD%E4%BB%A4%E8%A1%8C.pdf) | 全文读下来很舒服。不得不说linux命令行真是强大，认真看一遍，保留下来作为手册查看 :) 英文版本题目为<< The Linux Command Line>>。全地址：http://billie66.github.io/TLCL/\n\n<input type='checkbox' checked>[《Java编程思想(第4版)》](https://book.douban.com/subject/2130190/)| 从翻开这本书的第一页起，到现在三个月出头Orz。期间有达到过6页/h的阅读速度；阅读代码，理解，loop。不得不说，真的是圣经级别的书，感觉像是越级杀怪一样，难，很多东西感觉不是自己踩过坑，体会不会特别深，总之，已经加入书架必备书单。另外，从I/O部分开始，就没静下心来看了，最后图形化界面暂时搁置（惭愧rz）。（PS：看书和面试真的不是一个级别的东西啊TAT）\n\n<input type='checkbox' checked>[《MySQL必知必会》](https://book.douban.com/subject/3354490/) | 很好的入门书。虽然篇幅短，但是内容涵盖的还是很全面的。至于编写查询的各种技巧，还得自己深造了。\n\n<input type='checkbox' checked>[《计算机网络——自顶向下方法》](https://book.douban.com/subject/1391207/) | 看完了第五章，后续没有动力看下去了，暂且搁置。书中的TCP、UDP通信程序感觉很好玩。个人还是比较喜欢自底向上，自顶向下总是不爽讲着讲着又一个要之后才介绍的东西蹦出来。\n\n### 2016\n\n<input type='checkbox' checked>[《Learn Python The Hard Way》](https://github.com/GooZy/BookList/blob/master/2016/Learn_Python_The_Hard_Way_zh-cn.pdf) | 很好的入门书。把练习都做了，你会了解Python的。出乎意料的是竟然连自动化测试都有，表示很长见识。用Python头一次写了个[游戏](https://github.com/GooZy/Codes/tree/master/Language/Python/Lean%20python%20the%20hard%20way/SeekForTheLight)XD\n\n<input type='checkbox' checked>[《编码的奥秘》](https://book.douban.com/subject/1024570/) | 又名：计算机的前世今生XD。从电磁铁到处理器到计算机到操作系统，连多媒体技术都有，个人比较喜欢本书的前半部分。\n\n<input type='checkbox' checked> [《Sams Teach Yourself Java in 24 Hours》](https://github.com/GooZy/BookList/blob/master/2016/java-7-android-sams-teach-yourself-in-24-hours.pdf)| 介绍了Java在很多领域的应用，适合有点语言基础的人，虽然比较泛，但是能有个比较全面的认识\n\n<input type='checkbox' checked> [《GitHub入门与实践》](https://book.douban.com/subject/26462816/) | GitHub入门好书。记得多做笔记多搜索。\n\n<input type='checkbox' checked> [《learn with open source master》](https://github.com/zhuangbiaowei/learn-with-open-source) | 讲的略泛，个人感觉偏科普。",
      "data": {
        "title": "书单",
        "date": "2019-06-01 20:01:06",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "books"
    },
    {
      "content": "## About Me\n\n\n> 程序宅一枚~没事写写代码，看看动漫，打打游戏。  \n> 正在攻略：人生游戏\n\n\n## Contact Me\n\n- Email: ziyaoguo@gmail.com  \n- QQ: 751744014  # Hope we could be friends :)\n\n--------\n\n\n\n<a href=\"http://www.nerdtests.com/ft_nq.php\">\n<img src=\"http://www.nerdtests.com/images/ft/nq/1544a3365a.gif\" alt=\"I am nerdier than 75% of all people. Are you a nerd? Click here to take the Nerd Test, get geeky images and jokes, and write on the nerd forum!\" align=\"middle\"></a>\n\n<a href=\"http://s11.flagcounter.com/more/QPCC\"><img src=\"http://s11.flagcounter.com/count2/QPCC/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_10/viewers_0/labels_0/pageviews_0/flags_0/percent_0/\" alt=\"Flag Counter\" border=\"0\" style=\"float:right\"></a>",
      "data": {
        "title": "关于",
        "date": "2019-05-25 19:55:48",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "\n## 缘起\n\n从2016年冬季开始，我就有了看书会记些笔记的习惯，在比对了各个软件之后，选定了有道云笔记。主要看中了：1.免费；2.跨多个平台（手机、mac、windows）；3.可以用markdown写。\n\n<!--more-->\n\n这几年用下来，确实也还不错。但总有一些让我不满意的地方，一是有时候卡顿严重，几乎无法书写；二是笔记的版本管理，我在mac上使用时，查看笔记的版本，虽然软件提供了比对近30天版本的功能，但是我发现各版本的区别就是0和1的区别（下图显示3-5号和3-3号两版本没任何改动，但其实我本身是有改动的）；三是我怕某天笔记倒闭了我这几年的笔记就得一个一个慢慢下载下来了，十分被动；最后一点就是有道云笔记支持不了本地图片添加到markdown里面；\n\n![版本比较](https://user-images.githubusercontent.com/12698567/54083766-4631c180-4363-11e9-8a4d-955405592a4c.png)\n\n所以渐渐地，我也有了把笔记上传github的想法。可是彼时github私有仓库是收费的，而我又不想私密的笔记公开，所以就作罢。但是现在不一样了，github私有仓库免费了，所以我也开始着手自己的转移工作。\n\n## 所需工具\n\n- git，官网传送门：[点我](https://git-scm.com/)\n  - 开源的分布式版本控制系统\n- Typora，官网传送门：[点我](https://www.typora.io/)\n  - Typora是一个本地的[markdown](https://baike.baidu.com/item/markdown/3245829?fr=aladdin)编辑工具，支持Windows/Mac/Linux三大系统\n\n## 步骤\n\n#### 1. 建立自己的github私有仓库\n\n进入github官网，在个人仓库页面，新建私人仓库。\n\n![私有仓库](https://user-images.githubusercontent.com/12698567/54084273-b04d6500-4369-11e9-9fb3-c8ea4445ea9c.png)\n\n#### 2. 克隆到本地\n\n然后进入项目页面，克隆仓库到本地。\n\n![克隆1](https://user-images.githubusercontent.com/12698567/54084286-d07d2400-4369-11e9-9f58-4e2cc35d3a58.png)\n\n![克隆2](https://user-images.githubusercontent.com/12698567/54084287-d1ae5100-4369-11e9-894d-8ab8b90a53e9.png)\n\n#### 3. 设置Typora\n\n主要就是开启Typora的文件树视图。\n\n![t1](https://user-images.githubusercontent.com/12698567/54084318-1639ec80-436a-11e9-8f43-8b41abe2a338.png)\n\n然后打开你的仓库。\n\n![t2](https://user-images.githubusercontent.com/12698567/54084319-1639ec80-436a-11e9-816a-cbfd7c72f881.png)\n\n![t3](https://user-images.githubusercontent.com/12698567/54084320-176b1980-436a-11e9-95d6-21778630c3e1.png)\n\n之后所有的新建文件、目录操作都可以在文件树视图里面进行，不小心关闭了软件，只需要打开最近打开的文件，目录树自动就加载出来了。\n\n## 总结\n\n**优点**\n\n1. 本地图片放到同级目录下，就可以使用相对路径引入，在本地看笔记很方便。\n2. 所有笔记都在本地，同步到github，具有版本控制。\n3. 本地编辑，十分流畅。\n\n**缺点**\n\n1. 同步github比较麻烦，需要自己提交至github。（可以自己写个crontab命令进行定时检测仓库变动，然后上传github）\n2. 笔记的分享功能没有了。（这个我个人的解决方式是发布到[ubuntu pastebin](https://paste.ubuntu.com/)进行分享，本来是想推荐gist的，结果被墙了=。=)",
      "data": {
        "title": "如何用github和typora打造自己的云笔记",
        "date": "2019-03-10 18:21:55",
        "tags": [
          "总结"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n## 缘起\n\n从2016年冬季开始，我就有了看书会记些笔记的习惯，在比对了各个软件之后，选定了有道云笔记。主要看中了：1.免费；2.跨多个平台（手机、mac、windows）；3.可以用markdown写。",
      "fileName": "how-to-use-github-and-typora-to-build-your-own-cloud-note"
    },
    {
      "content": "\n## 前言\n\n本来是想着中秋来一场说走就走的旅行，结果在询问秦皇岛和青岛哪一个比较好玩的时候，恰巧他们也打算去，此行就此成立~\n\n## 主要行程\n\n<!--more-->\n\n[青岛之旅(1/3)——亚美综合市场、劈柴院、栈桥海水浴场](https://github.com/GooZy/GooZy.github.io/issues/12)\n\n[青岛之旅(2/3)——浙江路天主教堂、栈桥、奥林匹克帆船中心、八大关、第二海水浴场](https://github.com/GooZy/GooZy.github.io/issues/13)\n\n[青岛之旅(3/3)——金沙滩](https://github.com/GooZy/GooZy.github.io/issues/14)\n\n## 番外\n\n本次出行，总共花费大概1300左右，大部头在来回的动车票上，其余花费我觉得性价比都十分高。\n\n三天的行程结束，稍微认识了一座城，稍微认识了一群人。城市沿海真是老天莫大的垂帘。\n\n旅行总是能发现各种各样的细节，不论是人还是城市。\n\n海鲜这一趟真是吃到爽，便宜、好吃、量又多，2333。青岛的街道很小，小而精。这一趟之后，特别想去台湾看看，mark之。\n\nThanks♪(･ω･)ﾉ\n\n---\n\n\n\n**广告时间**\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n\n",
      "data": {
        "title": "青岛中秋三日游",
        "date": "2018-09-26 14:04:54",
        "tags": [
          "旅行"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n## 前言\n\n本来是想着中秋来一场说走就走的旅行，结果在询问秦皇岛和青岛哪一个比较好玩的时候，恰巧他们也打算去，此行就此成立~\n\n## 主要行程",
      "fileName": "Travel-Around-Qingdao-20180922"
    },
    {
      "content": "\n### 介绍\n\n首先是一个概念：置乱。意即将图像的信息次序打乱，使其变换成杂乱无章难以辨认的图像。\n\n用处大概就是：对图像加个密，除非你暴力破解，否则你不知道这是个啥。~~所以就能安心地在百度云上存些蜜汁图片~\\(≧▽≦)/~啦~~\n\n<!--more-->\n\n### Arnold变换\n\n也叫做猫脸变换，因为提出该算法的人当时是在一张猫的图片上操作，因此而得名= =\n\n这个变换公式很简单：\n\n![公式](https://user-images.githubusercontent.com/12698567/39406471-c4080f28-4be9-11e8-99f6-42f9a190093c.jpg)\n\n这里N代表图像的长宽，意即需要是正方形。当然，如果你想在长方形上尝试，把长方形切割成多个正方形，分别对正方形操作即可。Xn和Yn是原图像像素点位置，Xn+1和Yn+1该像素点的新位置。\n\n有两点十分神奇，我也不知道为什么：\n\n1. 单次变换后，所有像素点一一映射，也就是单映射。\n2. 经过一定的变换次数后，图像会变换成原来的样子。\n\n### 算法实现大致思路\n\n原图到新图就不说了，直接照着公式来。还原的话，只需要在公式两边乘上逆矩阵即可。\n\n具体可以看代码的arnold和iarnold部分：[传送门](https://github.com/GooZy/EasyW/blob/master/easyw/common/utils.py)\n\n### 参考资料\n\n1. [Arnold变换置乱图像](https://blog.csdn.net/yezi_happy/article/details/52804574)\n2. [python中有关矩阵的创建、求逆、转置](https://blog.csdn.net/shuaishuai3409/article/details/50830196)\n3. [百度百科：置乱](https://baike.baidu.com/item/%E7%BD%AE%E4%B9%B1/6575561?fr=aladdin)\n\n\n---\n\n**广告时间**\n\n> Java学习网站: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "Arnold变换(附Python实现)",
        "date": "2018-04-29 19:34:06",
        "tags": [
          "图像"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n### 介绍\n\n首先是一个概念：置乱。意即将图像的信息次序打乱，使其变换成杂乱无章难以辨认的图像。\n\n用处大概就是：对图像加个密，除非你暴力破解，否则你不知道这是个啥。~~所以就能安心地在百度云上存些蜜汁图片~\\(≧▽≦)/~啦~~",
      "fileName": "Arnold变换-附Python实现"
    },
    {
      "content": "\n## 前言\n\n北京室友大佬17年自己一个人去日本旅行过，今年旅行带上了我，程序宅于是有了一次出门~~（毕业旅行）~~的机会。\n\n## 主要行程一览\n\n<!--more-->\n\n[日本之旅(1/11)——新宿御苑、六本木之丘、目黑川樱花](https://github.com/GooZy/GooZy.github.io/issues/1)\n\n[日本之旅(2/11)——明治神宫、上野公园、秋叶原](https://github.com/GooZy/GooZy.github.io/issues/2)\n\n[日本之旅(3/11)——江之岛、镰仓、涩谷](https://github.com/GooZy/GooZy.github.io/issues/3)\n\n[日本之旅(4/11)——河口湖](https://github.com/GooZy/GooZy.github.io/issues/4)\n\n[日本之旅(5/11)——银座、台场、浅草寺、秋叶原](https://github.com/GooZy/GooZy.github.io/issues/5)\n\n[日本之旅(6/11)——大阪城、圣玛丽号、海游馆、天宝山摩天轮](https://github.com/GooZy/GooZy.github.io/issues/6)\n\n[日本之旅(7/11)——大阪城御座船、通天阁、浪速之汤、日本桥](https://github.com/GooZy/GooZy.github.io/issues/7)\n\n[日本之旅(8/11)——京都。八坂神社、清水寺、平安神宫、哲学之道、京都御所、晴明神社](https://github.com/GooZy/GooZy.github.io/issues/8)\n\n[日本之旅(9/11)——伏见稻荷大社、二条城、岚山](https://github.com/GooZy/GooZy.github.io/issues/9)\n\n[日本之旅(10/11)——宇治。平等院、大吉山、造币局樱花道](https://github.com/GooZy/GooZy.github.io/issues/10)\n\n## 番外\n\n11天的日本之旅结束（最后一天其实也就是去免税机场，然后回国），程序宅仿佛打开了新世界的大门：“旅行好像也是不错的事情呢”。\n\n从最初好奇，到现在的有所思，这段旅程收获还是颇丰的。最明显的一点就是，让我更想好好地游览自己的祖国了。我想知道幅员辽阔的中国，究竟是怎样一番模样。\n\n套用在造币局樱花道听到的一句日语：这样的感觉啊，还是第一次呢。以后也请好好旅行吧~\n\n- 这次的全部基本花费，即不可避免的花费：将近8000+ RMB\n\n\n- 日本上班族大部分都是西装革履呀。小学、中学、高中，也都是一路制服下来，怎么说呢，感慨吧，虽然制服好看，但是觉得有些拘束。\n- 日本修学旅行真棒呢，这几天天天都能见到学生们，啊，青春啊？！\n- 日本的井盖，嗯，怎么说呢，井盖不要钱系列，各个地方的都有自己特色。\n- 日本神社真的很多！\n- 关东扶梯靠左，关西扶梯靠右（然而关西有些地方又靠左），果然最正确的做法是跟着第一个人做\n- 日本环境保护以及文化开发是真的好，很宜居。\n- 但是啊，我真的吃不惯日式料理，还是中华料理第一！\n- 动漫人物喜欢的食物= =请一定不要抱太大希望尝试。\n- 教练，我想学日语！教练，我想学英语！\n- 御守狂魔推荐御守购买：江之岛某款全蓝的御守，音羽山（清水寺）的樱铃。（可惜我都没买，果然人生看到喜欢的东西当时就要去追求~）\n- 旅行推荐：明治神宫、秋叶原、江之岛、镰仓稻村崎站（踩沙滩）、河口湖、台场海滨公园、海游馆、天宝山摩天轮、浪速之汤（温泉赛高）、清水寺、哲学之道、伏见稻荷大社、岚山、大吉山\n\n---\n\n**广告时间**\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "日本之旅(4.4~4.14)",
        "date": "2018-04-05 22:09:23",
        "tags": [
          "日本"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n## 前言\n\n北京室友大佬17年自己一个人去日本旅行过，今年旅行带上了我，程序宅于是有了一次出门~~（毕业旅行）~~的机会。\n\n## 主要行程一览",
      "fileName": "日本之旅-4-4-4-14"
    },
    {
      "content": "\n### 本期题目\n\n在给出的10000张图片中，有一个单词重复出现了两次，请找出这个单词~\n\n<!--more-->\n\n来源：千里码 → [传送门](http://www.qlcoder.com/task/7557)\n\n### 正经\n\n首先当然是下载文件包，看看需要识别的都是什么图片啦。发现大部分都经过了旋转，变形倒没有，所以可以说是省下很大一笔功夫，然后调用开源的Tesseract-OCR愉快地识别。所以重点应该就是在如何把图片旋转回来:p\n\n先交代下我旋转前的前置步骤，放大->灰度->二值，OpenCV轻松完成。\n\n然后来个巨模糊的高斯模糊，主要就是为了让图片糊在一起，二值化后就只剩一个椭圆形轮廓。然后找到该轮廓的最小外接矩形，如果该矩形旋转度数为0，则不进行后续操作。否则，我们就去找矩形的上方、下方、左方、右方顶点。\n\n有了这四个顶点后，根据上方和下方顶点的相对位置，我们就能判定矩形到底是怎么斜的了，无非两种情况：k > 0 || k < 0。这个斜率k呢，我们可以用两条短边的中点算出来，这样倒着旋转度数，就可以开心地得到正常角度的单词啦~\\(≧▽≦)/~这里要注意OpenCV的坐标系，否则容易搞错顶点，如下图：\n\n![坐标系](http://7xsy54.com1.z0.glb.clouddn.com/coordinate.png)\n\n最后就是愉快的识别啦，首先直接拿下载的Tesseract-OCR进行识别，结果惨不忍睹，然后发现可以限定只识别小写字母以及单行处理，结果也是bad。无奈ㄟ( ▔, ▔ )ㄏ，只好自己动手，丰衣足食，进行训练，训练要记住的要点就是：找到26个字母都在训练集里就行！哇，我随机找了50张，标完了才发现还少了几个字母，被自己蠢哭TAT\n\n### 闲谈\n\n17年年末的夙愿=。=，结果拖到了现在才做完。当初大一数字识别各种网上找资料，MFC简直反人类。工作后接触比较多的就是OCR了，证照识别，验证码识别，不过仅仅都如前文所说，只是尽力做些预处理，真正核心的识别原理还没时间去了解，这个下来自己也想好好看看，嘿嘿😜\n\n本期代码链接 → [传送门](https://github.com/GooZy/OCR)\n\n---\n\n**广告时间**\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "光学字符识别-闲谈3",
        "date": "2018-01-24 23:17:34",
        "tags": [
          "图像"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n### 本期题目\n\n在给出的10000张图片中，有一个单词重复出现了两次，请找出这个单词~",
      "fileName": "光学字符识别-闲谈3"
    },
    {
      "content": "\n### 本期题目\n\n一起来玩生命游戏~\n\n这是一款二维平面游戏，模拟生命的演化过程，规则十分简单：\n\n<!--more-->\n\n> 如果一个生命体周围少于2生命体，那么该生命体会因为人口缺少而在下一轮死去，这个格子变成了空地。\n>\n> 如果一个生命体周围大于3个生命体，那么该生命体会因为人口的过度拥挤，资源匮乏，而在下一轮死去。这个格子变成空地。\n>\n> 如果一个生命体周围有2-3个生命体，那么该生命体能在下一轮继续活下去。\n>\n> 如果一个空地周围有3个生命体，那么该空地在下一轮会繁殖出新的生命体\n\n总结起来就是：有生命的格子，仅当周围存在2~3个生命体才能存活下来；无生命的格子，仅当周围有3个生命体，才能孕育出生命。\n\n维基百科上的动图十分生动，可以看看 https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\n\n这次的任务是给出初始的五个格子，说出在第几轮的时候，演化出最多的生命体\n\n![初始图](http://121.201.63.168/uploads/145017871936742.png)\n\n来源：千里码 → [传送门](http://www.qlcoder.com/task/75d8)\n\n### 正经\n\n首先看看这个图是怎么演化的 [传送](https://github.com/GooZy/Codes/blob/master/qlcoder/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F%E6%BC%94%E5%8C%96.py)\n\n各种方向四处飞，初始化个很大的地图模拟过程应该是不行了= =\n\n考虑上方自己写代码的时候，其实用到的只有生命体和它周围的8个格子，那么是否可以只存下这些生命体的坐标位置？\n\n最终方案为：字典键记录生命体坐标，值记录周围生命体个数，每次迭代做一次备份，循环演化即可。\n\n### 闲谈\n\n生命体游戏啊，很早就想写一个了，理想中是写个图形界面的，这次用控制台输出感觉也不错，哈哈哈。\n\n感觉题目介绍的无边界地图和我的认知稍微不同。个人认为的无边界是伪无边界，程序本身有存一份很大的地图，然后随着角色的走动，动态加载其中的一部分。\n\n本题给我的感觉是只记录必要信息= =\n\n来张帅气的控制台图：\n\n![生命游戏控制台](http://7xsy54.com1.z0.glb.clouddn.com/%E6%97%A0%E8%BE%B9%E7%95%8C%E5%9C%B0%E5%9B%BE.png)\n\n本期代码链接 → [传送门](https://github.com/GooZy/Codes/blob/master/qlcoder/%E6%97%A0%E8%BE%B9%E7%95%8C%E5%9C%B0%E5%9B%BE.py)\n\n\n---\n\n**广告时间**\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "无边界地图[闲谈2]",
        "date": "2017-11-25 17:49:56",
        "tags": [
          "生命游戏",
          "无边界地图"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n### 本期题目\n\n一起来玩生命游戏~\n\n这是一款二维平面游戏，模拟生命的演化过程，规则十分简单：",
      "fileName": "无边界地图-闲谈2"
    },
    {
      "content": "\n### 开题介绍~\n\n打算开一个“闲谈”专题，定期(不定期?)收录一些自己觉得有趣的题，记录解题过程~\n\n<!--more-->\n\n### 本期题目\n\n一共有十个时刻变化的页面，他们的更新频率不尽相同，需要给出这十个页面的频率排序\n\n来源：千里码 → [传送门](http://www.qlcoder.com/task/7569)\n\n### 正经\n\n分析题目，大概就是需要做两件事情：比对页面是否相同、调整爬取频率\n\n需要比对同一页面差别的话，那可以考虑计算整个页面的md5值，这样就可以直接看出差别。谈优化的话，我觉得可以去除所有对人眼识别不相关的元素之后进行md5，比如页面空格。\n\n爬取频率调整，感觉可以考虑参考TCP拥塞控制那样，初期成倍增长，当页面变化时停止成倍增长，转而变成1.1倍的增和减。\n\n十个页面的话，开十个进程嘛，妥妥的:p 然后就放着跑等结果吧，2333\n\n### 闲谈\n\n感觉爬虫的频率适配是个不错的想法，每个页面使用不同的频率爬取，节约资源。不过对于垂直爬虫这一类别，个人感觉还是不适用，还是根据网站量级制定频率比较稳妥= =\n\n诶，这么想的话，垂直爬虫只要能够制定一个网站的判重规则不就行了么，嘿嘿= =哇，这能怎么做。。。。。。\n\n本期代码链接 → [传送门](https://github.com/GooZy/Codes/blob/master/qlcoder/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB.py)\n\n\n---\n\n**广告时间**\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "动态爬虫[闲谈1]",
        "date": "2017-11-18 14:48:03",
        "tags": [
          "爬虫"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n### 开题介绍~\n\n打算开一个“闲谈”专题，定期(不定期?)收录一些自己觉得有趣的题，记录解题过程~",
      "fileName": "动态爬虫-闲谈1"
    },
    {
      "content": "\n### 前言\n\n最近业务上需要表现一些数据间的层级关系，考虑到关系型数据库的联表查询随着量级增大，复杂度骤增，打算采用图数据来存储这一部分数据用于展示。\n\n<!--more-->\n\n#### 介绍\n\nNeo4j是一款开源的图形数据库，以图形结构的形式存储数据。\n\n下载地址：<https://neo4j.com/download/other-releases/#releases>\n\n解压后进入目录输入：`./bin/neo4j console` 即可启动，初始账号密码均为 neo4j\n\n也可以直接在线尝试：<https://neo4j.com/sandbox-v2/?ref=product>\n\n#### 与关系型数据库对比\n\n![neo4j](http://7xsy54.com1.z0.glb.clouddn.com/image2017-11-16_15-44-14.png)\n\n| 关系型数据库 | 图数据库                                     |\n| ------ | ---------------------------------------- |\n| 表      | 标签（每个节点都有自己所属的标签，标签内的节点可以看做一个组，单个节点可以拥有多个标签，上方财政部的标签就是Person） |\n| 行      | 节点（节点记录着节点属性，单个节点拥有多个属性（建议越少越好，因为主要关注在点与点间关系上）） |\n| 列      | 属性名                                      |\n| 表间关系   | 节点间关系（关系带有标签，一个标签下可以有多个属性值，例如上方的参股就是一个关系标签） |\n| SQL    | Cypher（专有查询语言）                           |\n\n#### Cypher\n\n总：<http://neo4j.com/docs/cypher-refcard/3.0/>\n\nCypher命令不区分大小写，但是属性值是区分的\n\n**增**\n\n```sql\nCREATE (a:Person { name: \"Guo\", from: \"China\", age: 22 }),\n(b:Person { name: \"Zi\", from: \"China\", age: 22 }),\n(a)-[r:Knows {since: 1995}]->(b)\nRETURN a, r, b\n```\n\n建立一个标签为Person，具有三个属性name、from、age的节点，a为变量名。然后建立两者的单向关系，其中Knows为关系标签，具有属性since。使用()来表示节点，{}表示节点属性\n\n**查**\n\n```sql\nMATCH (a:Person), (b:Person)\nWHERE a.name = \"Guo\" AND b.name = \"Zi\"\nreturn a, b;\n```\n\n**删**\n\n```sql\nMATCH (b:Person)\nWHERE  b.name = \"Zi\"\nDETACH DELETE b;\n```\n\nDETACH会删除节点及与该节点相关的关系\n\n**改**\n\n```sql\nMATCH (n)\nwhere n.name='Guo'\nset n.Company='Team'\nreturn n;\n```\n\n#### 与Python交互\n\n总：<https://neo4j.com/docs/api/python-driver/1.5/>\n\n官方有提供驱动，但是我更推荐使用py2neo，使用起来更便捷\n\npy2neo(3.0版本)：<http://py2neo.org/v3/>\n\n**增删改查**\n\n```python\nfrom py2neo import Graph, Node, Relationship\n \ngraph = Graph(\n    \"http://localhost:7474\",\n    username=\"neo4j\",\n    password=\"000000\"\n)\n \n \n# 增\nfather = Node('Person', name='A')\nchild = Node('Person', name='B')\ngraph.create(father)\ngraph.create(child)\ngraph.create(Relationship(father, 'Father_of', child))\n# 改\nfather['name'] = 'C'\ngraph.push(father)\n# 查\nx = graph.find_one('Person', 'name', 'C')  # lable, key, value\n# 删\ngraph.delete(x)\n```\n\n#### 关系数据库导入到图数据库\n\n参考：<http://paradoxlife.me/how-to-insert-bulk-data-into-neo4j>\n\n对于少量数据（文件必须放在neo4j的impot目录下）\n\n```shell\nload csv with headers from \"file:///clue_invest.csv\" as line\nmerge (p:Invest{company_name: line.company_name, name: line.name, level: line.level})\n```\n\n对于大量数据，可以考虑生成csv导入（header和数据分开有利于后期更改）\n\n可以参考：<http://blog.csdn.net/macanv/article/details/78296066>\n\n命令不要加多余空格，另外neo4j-import之后会考虑废弃，所以推荐使用neo4j-admin来进行\n\n```bash\n/Users/guoziyao/Desktop/neo4j-community-3.3.0/bin/neo4j-admin import --mode csv -nodes:Company company_header.csv,company.csv --nodes:Person person_header.csv,person.csv -relationships relationship.csv\n```\n\n#### 总结\n\n以上便是这段时间学习的一个总结，更多的用法可以查看官方文档，以及给出的一些参考:)\n\n---\n\n**广告时间**\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "图数据库Neo4j总结",
        "date": "2017-11-16 23:34:58",
        "tags": [
          "总结"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n### 前言\n\n最近业务上需要表现一些数据间的层级关系，考虑到关系型数据库的联表查询随着量级增大，复杂度骤增，打算采用图数据来存储这一部分数据用于展示。",
      "fileName": "图数据库Neo4j总结"
    },
    {
      "content": "\n**UPDATE 2018.05.30**\n\nHyperComments将于**2018.06.15**起不再提供免费服务。~~需要免费评论系统的，可以参考这篇文章“[Gitment：使用 GitHub Issues 搭建评论系统](https://imsun.net/posts/gitment-introduction/)”了。目前博客将采用gitment作为评论系统，有疑问的可以到[留言页](https://goozy.github.io/bbs/)留言，旧文章不再提供评论，新文章可正常评论。~~\n\n**UPDATE 2018.09.27**\n\n如今giment也GG了，正式换成[valine](https://valine.js.org/hexo.html)，顺带把主题升级到6.x了，累=。=\n\n**UPDATE 2019.06.01**\n\n改用[gridea](https://github.com/getgridea/gridea)管理博客了，挺好用的，现在的评论系统是内置的gittalk。\n\n### 起因\n\n[多说不再提供评论服务。](http://dev.duoshuo.com/threads/58d1169ae293b89a20c57241)\n\n<!--more-->\n\n### 为什么使用HyperComments\n\n一开始我也是拒绝的，因为看原博客要改几个文件，嫌太麻烦（事实上改文件还不到10分钟，复制粘贴，over）。然后找了下国内的某些知名评论系统，下面是对比结果：\n\n- 网易云跟帖\n  - 评论会显示某某地区网友。\n  - 注册站点竟然说已经被注册过 = =！\n- 来必力\n  - 无法使用邮箱进行匿名回复，只能社交账号登陆。\n- 畅言\n  - 注册的站点竟然要备案！\n  - 还有网站注册系统，只能用手机号注册我也是醉了。\n- 友言\n  - 无法使用邮箱进行匿名回复，只能社交账号登陆。\n\n#### HyperComments的缺点\n\n1. 站点管理界面是英文，对于英语苦手体验不好。\n2. 致命的缺点：**只能用google账号登录**(不能翻墙的童鞋绕行吧TAT)\n3. 多说的评论导入不了。\n\n#### HyperComments的优点\n\n1. 免费版本最多支持每月100K的部件加载次数。换算成每天就是3333次的加载量，对于个人博客来说，我觉得还不错。\n2. 界面简洁，没有XXX地区网友留言之类的头衔附加到留言处。\n3. 支持填写邮箱进行回复，不需要强制登录第三方账号。\n4. 支持emoji和回复添加附件 :)\n5. 评论框不需要访客翻墙也能显示出来。(好像是家俄罗斯的公司，2333)\n\n#### 总结\n\n综上，我觉得HyperComments是这几个之中最好的。\n\n### Next主题配置HyperComments\n\n因为参考的教程是Next主题的，其它主题不知道行不行，看官请自便XD\n\n#### 1. 登录官网，购买免费版本\n\n官网链接：[https://www.hypercomments.com/pricing](https://www.hypercomments.com/pricing)\n\n#### 2. 配置主题配置文件\n\n再填写完必要信息后，会出现代码，其中第四行：`_hcwp.push({widget:\"Stream\", widget_id: xxxx});`，复制这个ID，打开主题配置文件`GooZy.github.io/themes/next/_config.yml`，加入如下描述：\n```\n# Hypercomments\nhypercomments_id: xxxx\n```\n\n没找到ID的，可以登录到管理页面，点击设置按钮，打开左侧的Widget下的code即可看到代码。顺带一提：code下的General可以设置评论提醒，大家自行摸索吧XD\n\n#### 3. 最终步骤：改写和添加文件\n\n首先是文件`/themes/next/layout/_macro/post.swig`，打开后，在如下位置添加代码。其中**第5行到第16行**是新添代码，具体位置使用编辑器ctrl + f查找`<span class=\"post-comments-count disqus-comment-count\" data-disqus-identifier=\"{{ post.path }}\" itemprop=\"commentsCount\"></span>`即可找到。\n``` javascript\n                <a href=\"{{ url_for(post.path) }}#comments\" itemprop=\"discussionUrl\">\n                  <span class=\"post-comments-count disqus-comment-count\" data-disqus-identifier=\"{{ post.path }}\" itemprop=\"commentsCount\"></span>\n                </a>\n              </span>\n           {% elseif theme.hypercomments_id %}\n           <!--noindex-->\n              <span class=\"post-comments-count\">\n               &nbsp;|&nbsp;\n                 <span class=\"post-meta-item-icon\">\n                   <i class=\"fa fa-comment-o\"></i>\n                   <a href=\"{{ url_for(post.path) }}#comments\" itemprop=\"discussionUrl\">\n                     <span class=\"post-comments-count hc-comment-count\" data-xid=\"{{ post.path }}\" itemprop=\"commentsCount\"></span>\n                   </a>\n                 </span>\n             </span>\n             <!--/noindex-->\n            {% endif %}\n          {% endif %}\n```\n\n接着修改`themes/next/layout/_partials/comments.swig`，**第8行到第9行**为新增代码\n``` javascript\n    {% elseif theme.disqus_shortname %}\n      <div id=\"disqus_thread\">\n        <noscript>\n          Please enable JavaScript to view the\n          <a href=\"//disqus.com/?ref_noscript\">comments powered by Disqus.</a>\n        </noscript>\n      </div>\n    {% elseif theme.hypercomments_id %}\n      <div id=\"hypercomments_widget\"></div>\n    {% endif %}\n  </div>\n{% endif %}\n```\n\n然后修改`themes/next/layout/_scripts/third-party/comments.swig`，**第3行**为新增代码\n``` javascript\n{% include './comments/duoshuo.swig' %}\n{% include './comments/disqus.swig' %}\n{% include './comments/hypercomments.swig' %}\n```\n\n最后新建文件`themes/next/layout/_scripts/third-party/comments/hypercomments.swig`，写入：\n``` javascript\n{% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname %}\n\n\t{% if theme.hypercomments_id %}\n\n\t\t<script type=\"text/javascript\">\n\t\t_hcwp = window._hcwp || [];\n\n\t\t_hcwp.push({widget:\"Bloggerstream\", widget_id: {{ theme.hypercomments_id }}, selector:\".hc-comment-count\", label: \"{\\%COUNT%\\}\" });\n\n\t\t{% if page.comments %}\n\t\t_hcwp.push({widget:\"Stream\", widget_id: {{ theme.hypercomments_id }}, xid: \"{{ page.path }}\"});\n\t\t{% endif %}\n\n\t\t(function() {\n\t\tif(\"HC_LOAD_INIT\" in window)return;\n\t\tHC_LOAD_INIT = true;\n\t\tvar lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || \"en\").substr(0, 2).toLowerCase();\n\t\tvar hcc = document.createElement(\"script\"); hcc.type = \"text/javascript\"; hcc.async = true;\n\t\thcc.src = (\"https:\" == document.location.protocol ? \"https\" : \"http\")+\"://w.hypercomments.com/widget/hc/{{ theme.hypercomments_id }}/\"+lang+\"/widget.js\";\n\t\tvar s = document.getElementsByTagName(\"script\")[0];\n\t\ts.parentNode.insertBefore(hcc, s.nextSibling);\n\t\t})();\n\t\t</script>\n\n\t{% endif %}\n\n{% endif %}\n```\n\n好啦！大功告成~然后就可以去DIY下HyperComments的后台管理，探索新大陆啦~\n\n代码部分有看不懂的，可以看下方参考资料的代码。\n\n### 参考资料\n\n1. [Гиперкомментарии для темы Next в Hexo](https://almostover.ru/2016-10/add-hypercomments-to-hexo-theme-next/)\n\n---\n\n**广告时间**\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "从今天开始使用HyperComments啦！",
        "date": "2017-03-22 20:16:24",
        "tags": [
          "HyperComments",
          "总结"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n**UPDATE 2018.05.30**\n\nHyperComments将于**2018.06.15**起不再提供免费服务。~~需要免费评论系统的，可以参考这篇文章“[Gitment：使用 GitHub Issues 搭建评论系统](https://imsun.net/posts/gitment-introduction/)”了。目前博客将采用gitment作为评论系统，有疑问的可以到[留言页](https://goozy.github.io/bbs/)留言，旧文章不再提供评论，新文章可正常评论。~~\n\n**UPDATE 2018.09.27**\n\n如今giment也GG了，正式换成[valine](https://valine.js.org/hexo.html)，顺带把主题升级到6.x了，累=。=\n\n**UPDATE 2019.06.01**\n\n改用[gridea](https://github.com/getgridea/gridea)管理博客了，挺好用的，现在的评论系统是内置的gittalk。\n\n### 起因\n\n[多说不再提供评论服务。](http://dev.duoshuo.com/threads/58d1169ae293b89a20c57241)",
      "fileName": "从今天开始使用HyperComments啦！"
    },
    {
      "content": "\n最近想学学集合框架的源代码，结果画风是这样的：\n\n``` Java\nboolean addAll(Collection<? extends E> c);\ndefault boolean removeIf(Predicate<? super E> filter) {\n\t...\n}\nboolean containsAll(Collection<?> c);\n```\n\n一下就暴露了泛型没好好学的锅= =，今天总结一下。\n\n<!--more-->\n\n下文统一使用这两个类进行说明。\n\n``` Java\nclass Fruit {}\nclass Apple extends Fruit {}\n```\n\n### 泛型中的通配符\n\n#### 上边界限定通配符\n\n用法：`<? extends Fruit>`\n\n即当前类型 `X = ? extends Fruit`，类似`X <= Fruit`的感觉\n\n这个X类型，表示是某个Fruit子类(或者Fruit本身)的类型，这也就意味着X类型有多种可能性，而编译器无法判定是哪一个类型，所以通过这种方法声明的List无法添加元素，只允许取出元素，取出的元素全都会向上转型。\n\n#### 下边界限定通配符/超类型的通配符\n\n用法：`<? super Fruit>`\n\n即当前类型 `X = ? super Fruit`，类似`X >= Fruit`的感觉\n\n这里的X类型，表示是某个Fruit父类(或者Fruit本身)的类型，虽然这里的X的类型也有多种可能性，但是编译器可以断定，只要加入的类型是Fruit子类或者Fruit本身，就一定可以向上转型。所以通过这种方法声明的List允许添加Fruit及其子类型的对象，加入的对象会自动向上转型成Fruit。\n\n与上边界通配符的配合：\n``` Java\nclass Test {\n    public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n        for (int i = 0; i < src.size(); i++)\n            dest.set(i, src.get(i));\n    }\n}\n```\n\n#### 无边界通配符\n\n用法：`<?>`\n\n即当前类型X不限定范围，可能是任意的一个类型。所以自然也就无法向其添加任何元素了。用法类似于`extends`，不过`get`出来的是`Object`类型就是了。\n\n### PS\n\n引子中的`removeIf`是一个默认方法，不得不赞一发，既扩展了接口方法，又不使得实现接口的类去添加新方法的覆盖，具体见参考资料。之后别人再问接口和抽象类的区别，就不能说普通类实现接口一定要实现所有方法了，2333。\n\n### 参考资料\n\n1. [Java 泛型总结（三）：通配符的使用](https://segmentfault.com/a/1190000005337789#articleHeader0)\n2. [Java 8 默认方法（Default Methods）](http://ebnbin.com/2015/12/20/java-8-default-methods/)\n\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "Java泛型中的通配符",
        "date": "2017-03-20 19:11:05",
        "tags": [
          "Java",
          "泛型"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n最近想学学集合框架的源代码，结果画风是这样的：\n\n``` Java\nboolean addAll(Collection<? extends E> c);\ndefault boolean removeIf(Predicate<? super E> filter) {\n\t...\n}\nboolean containsAll(Collection<?> c);\n```\n\n一下就暴露了泛型没好好学的锅= =，今天总结一下。",
      "fileName": "Java泛型中的通配符"
    },
    {
      "content": "\n今天看Java的时候突然好奇`parseInt()`的实现，想着会不会和自己平常比赛时候的实现方法一样。于是就翻到了这个：\n\n<!--more-->\n\n``` Java\npublic static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s == null) {\n            throw new NumberFormatException(\"null\");\n        }\n\n        if (radix < Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix > Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        int result = 0;\n        boolean negative = false;\n        int i = 0, len = s.length();\n        int limit = -Integer.MAX_VALUE;\n        int multmin;\n        int digit;\n\n        if (len > 0) {\n            char firstChar = s.charAt(0);\n            if (firstChar < '0') { // Possible leading \"+\" or \"-\"\n                if (firstChar == '-') {\n                    negative = true;\n                    limit = Integer.MIN_VALUE;\n                } else if (firstChar != '+')\n                    throw NumberFormatException.forInputString(s);\n\n                if (len == 1) // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s);\n                i++;\n            }\n            multmin = limit / radix;\n            while (i < len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                digit = Character.digit(s.charAt(i++),radix);\n                if (digit < 0) {\n                    throw NumberFormatException.forInputString(s);\n                }\n                if (result < multmin) {\n                    throw NumberFormatException.forInputString(s);\n                }\n                result *= radix;\n                if (result < limit + digit) {\n                    throw NumberFormatException.forInputString(s);\n                }\n                result -= digit;\n            }\n        } else {\n            throw NumberFormatException.forInputString(s);\n        }\n        return negative ? result : -result;\n    }\n```\n\n\n\n整体思路也是先乘基数，然后加值，多了对溢出的判断。在计算结果时，不是像我平常使用正数存储，而是默认是负数。不是很理解，然后注释说防止接近`MAX_VALUE`。发现：`INT_MAX = 2147483647 、 INT_MIN = -2147483648`。那么答案就很明显了，如果默认为正数的话，当值为`INT_MIN`时，会造成溢出，最终异常。好严谨Orz\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "关于Java中parseInt的一个趣事",
        "date": "2016-11-24 23:19:00",
        "tags": [
          "Java"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n今天看Java的时候突然好奇`parseInt()`的实现，想着会不会和自己平常比赛时候的实现方法一样。于是就翻到了这个：",
      "fileName": "关于java中parseInt的一个趣事"
    },
    {
      "content": "\n### 笔记\n\n-  `git diff HEAD` (查看本次提交和上次提交的区别)\n\n-  `git reset --hard hashValue` 回退到哈希值对应版本。这条命令会把你工作目录中所有未提交的内容清空(当然这不包括未置于版控制下的文件 untracked files)\n\n-  `git checkout -- xx.txt` 恢复单个文件\n\n-  `git commit --amend` 修改最近一次的提交信息\n\n-  `git commit -am '...'` 个别文件修改时，直接这样，省事。\n\n   <!--more-->\n\n-  **分支操作**\n   - `git branch` (显示分支一览表)\n   - `git branch xxx` (创建分支xxx)\n   - `git checkout xxx` (切换到分支xxx)\n   - `git checkout -b xxx` (上方两命令的合成)\n   - `git checkout -` (切换回上一个分支)\n   - `git merge --no-ff xxx` (合并xxx到当前分支，关闭fast-forward，保留commit历史)\n   - `git branch -D xxx` 删除分支xxx\n   - `git branch -a` (查看所有分支)\n   - `git branch -r` (查看远程分支)\n\n-  `git reflog` (查看当前仓库的操作日志)\n\n-  发送pull request\n   - 首先网页上fork\n   - 然后`git clone git@github.com:username/proName`\n   - 创建特性(Topic)分支。\n      - `git checkout -b work xxx`(xxx为源分支)\n   - 修改文件\n   - `git diff`查看修改是否正确进行\n   - 全部确认完毕后提交到本地仓库。`git add xxx` 和 `git commit -m 'xxx'`\n   - 由于目前只建立了本地的分支work，还需在远程建立此分支。`git push origin work` 在远程建立这个分支。\n   - 从网页进入分支。提交PR\n\n-  `git fetch xxx` 更新分支xxx到最新版本。此时需要手动进行merge。这种做法比较安全\n\n-  接收pull request\n   - 首先，我们把**接收方**仓库clone到本地。已经clone过的，就通过pull更新到最新版。\n   - 然后，把**发送方**的仓库设置为远程仓库(`git remote add name git@github.com:prSender/repoName`)。接着fetch到本地。\n   - 建立一个分支merge刚才fetch的内容。接着就是看看程序是否没有问题。\n   - 没问题，你就把这个分支删了吧。\n   - 最后到网页接收PR即可。\n      - 当然，也可以切换到主分支，进行合并，然后push到github，此时PR会自动关闭。\n\n-  与github相互协作的工具或服务\n\n   - hub。完全包含git的所有命令，并且对其进行了简化和扩展。\n   - Travis CI(Continuous Integration)。可以在开发者执行提交后立即进行测试和构建。Travis Weblint检查配置文件.travis.yml是否错误。有些仓库的readme中显示有些条状状态，正是Travis CI的测试结果的显示。\n   - Coveralls。代码覆盖率检测服务。\n   - Gemnasium。查询github仓库正在使用的RubyGems或npm(Node Package Manager)，让开发者了解自己是否正在使用新版本进行开发。\n   - Code Climate。只支持Ruby，提供代码分析报告服务，对代码质量进行评定，指出质量有问题代码。收费。\n   - Jenkins。持续集成开发服务。主要用于持续、自动地构建/测试软件项目和监控一些定时执行的任务。\n\n\n### 书评\n\n这本书可以算是一本**工具书**+**经验书**。  书中有很多的命令，所以记笔记是必须的。另外作者也会根据自己的经历给出一些开发中需要注意的事项。对于入门而言我觉得是极好的一本书，剩下的提高就要看自己之后的实践了。此外书不大，作为参考书放着也是极好的。\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "GitHub入门与实践 笔记+书评",
        "date": "2016-11-23 14:35:04",
        "tags": [
          "git",
          "笔记",
          "开源"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n### 笔记\n\n-  `git diff HEAD` (查看本次提交和上次提交的区别)\n\n-  `git reset --hard hashValue` 回退到哈希值对应版本。这条命令会把你工作目录中所有未提交的内容清空(当然这不包括未置于版控制下的文件 untracked files)\n\n-  `git checkout -- xx.txt` 恢复单个文件\n\n-  `git commit --amend` 修改最近一次的提交信息\n\n-  `git commit -am '...'` 个别文件修改时，直接这样，省事。",
      "fileName": "GitHub入门与实践-笔记-书评"
    },
    {
      "content": "\n### 题目链接：\n\n[Codeforces 706E Working routine (模拟链表)](http://codeforces.com/problemset/problem/706/E)\n\n### 题意分析：\n\n给出一个矩阵和q个操作，每次操作需要交换矩阵的两个子矩形，问：经过q次操作后，最终矩阵长什么样子。\n\n<!--more-->\n\n### 解题思路：\n\n$1000 \\times 1000$ 的矩阵啊，$n^{2}$ 操作肯定是要T的。考虑链表将整个矩阵串在一起，如下图：\n\n![](http://7xsy54.com1.z0.glb.clouddn.com/Codeforces%20706E%20Working%20routine.png)\n\n发现对于任意需要我们交换的矩阵，其实我们只需要改变这两个矩阵的周围一圈元素的指针指向即可完成两个矩阵的交换。单次操作复杂度就降到了O(n + m)了。另外我们只需要知道元素的右边下边是什么，并不用关心上方，左方是什么，所以只用存储两个方向即可。\n\n### 个人感受：\n\n链表赛高！\n\n### 具体代码链接：\n\n[传送门](https://github.com/GooZy/Codes/blob/master/OJ-Codeforces/%23367%20div2/Working%20routine.cpp)\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "Codeforces 706E Working routine (模拟链表)",
        "date": "2016-08-12 23:31:40",
        "tags": [
          "链表",
          "实现",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n### 题目链接：\n\n[Codeforces 706E Working routine (模拟链表)](http://codeforces.com/problemset/problem/706/E)\n\n### 题意分析：\n\n给出一个矩阵和q个操作，每次操作需要交换矩阵的两个子矩形，问：经过q次操作后，最终矩阵长什么样子。",
      "fileName": "Codeforces-706E-Working-routine-模拟链表"
    },
    {
      "content": "\n### 题目链接：\n\n[HDU 5812 Distance](http://acm.hdu.edu.cn/showproblem.php?pid=5812)\n\n### 题意分析：\n\n给出一个空集合和三个操作。操作I向集合中插入元素X，操作D删除集合中的元素X，操作Q，查询集合中与X的最小距离最小是多少？   \n定义最小距离 $d(x,y)$ 为从x变为y只通过乘或者除素数所需要的最少操作。例如：$d(15, 50) = 3$，因为 $15 / 3 \\times 2 \\times 5 = 50$\n<!--more-->\n\n### 解题思路：\n\n1. 求d函数第一反应就是把两个元素分解成质因数，然后去掉公共的部分，剩下的就不是公共部分，必须通过乘法和除法才能变为对方。所以有 $d(x,y) = f(x / gcd(x,y)) + f(y / gcd(x, y))$ 其中 $f(x)$ 是该数的质因子个数。（看到式子感觉确实挺显然的，但比赛中去掉公共部分后就没怎么往这方面想）\n\n2. 考虑枚举x的约数，那么现在问题就在于如何快速的对整个集合中的可行元素求出 $f(y / gcd(x, y))$ 显然，此时只有集合中是约数倍数的数才需要被考虑（这样才能和x一样整除约数）。\n\n3. 尝试定义数组d[i]，代表集合中以i为约数，能达到的最小f值。那么每加入一个集合中不存在的值X，我们就能将X进行约数分解，比如分解成了 $X = y \\times z$，那么就能这么更新:\n`d[y] = min(d[y], f[z]); d[z] = min(d[z], f[y]); `  \n然而这样存在一个问题，当能得到最小值的那个元素被删除后，d[]数组的值就不知道该怎么更新了。也许可以记录次小值，那如果次小被删除呢？第三小？所以显然要转换下策略。\n\n4. 由于对于一个数x，他的质因数个数不超过20个（$2^20 = 1048576$），所以我们直接把所有可行值存下来，然后遍历二进制位，找到最小的那一位1所在位置，就是d[]数组对应的值了。所以我们d[]数组存放二进制即可。比如d[3] = 0000101010,那么最小的f值就是1了。\n\n5. 最后我们开个二维数组c[i][j]：记录约数i能得到的f值j出现的次，用它来维护d[]数组的更新即可（次数为0说明不存在了，要剔除）。\n\n### 个人感受：\n\n这场多校题感觉都好劲啊，那种细细读题解，然后恍然大悟的感觉，那道炉石的DP也是。不像有些场，看了题解一脸懵比。\n\n### 具体代码链接：\n\n[传送门](https://github.com/GooZy/Codes/blob/master/Trainning/2016%E5%A4%9A%E6%A0%A1%E7%AC%AC07%E5%9C%BA/Distance.cpp)\n\n\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "HDU 5812 Distance",
        "date": "2016-08-10 14:22:42",
        "tags": [
          "实现",
          "二进制",
          "数学"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n### 题目链接：\n\n[HDU 5812 Distance](http://acm.hdu.edu.cn/showproblem.php?pid=5812)\n\n### 题意分析：\n\n给出一个空集合和三个操作。操作I向集合中插入元素X，操作D删除集合中的元素X，操作Q，查询集合中与X的最小距离最小是多少？   \n定义最小距离 $d(x,y)$ 为从x变为y只通过乘或者除素数所需要的最少操作。例如：$d(15, 50) = 3$，因为 $15 / 3 \\times 2 \\times 5 = 50$",
      "fileName": "HDU-5812-Distance"
    },
    {
      "content": "\n### 前言\n数据结构亦可赛艇！我已经中了树的煮粥XD坐等官方题解，学习一波剩下的题Orz 丧病韬面向AC出数据，至今不会那题TAT\n\n<!--more-->\n\n--------\n\n\n### B. 发糖游戏1+1\n\n#### 题意\n\n两种姿势发糖，具体看题目描述= =\n\n#### 分析\n\n1. 线段树 单点更新，区间查询 + 区间更新，单点查询\n\n#### 思考\n\n1. 坑点： 无。\n2. 技巧： 基础。\n\n\n--------\n\n\n\n### E. 组队方案数\n\n#### 题意\n\n寻找公比为k的三个数的个数（这三个数根据相对位置从左到右排列）。\n\n#### 分析\n\n1. 找等比数列。相对位置确定，如果当前数字为x，那么我们从后往前统计的话，就能知道有多少个kx，顺带也能统计出kx之后有多少个kkx。使用两个map，一个存kx，一个存kkx。2. 设两个map分别为ans和cnt，ans[i]记录i和$i\\times k$的组合个数，cnt[i]记录到目前位置i出现了多少次。\n3. 所以有转移：  \n答案 += ans[当前值 $\\times k$];  \nans[当前值] += cnt[当前值 $\\times k$];  \n++cnt[当前值];\n\n#### 思考\n\n1. 坑点： 公比为0、1之类的。之前转移没考虑清楚还特判这种情况，现在的转移不需要特判。\n2. 技巧： 思考。\n\n\n--------\n\n\n\n### F. goozy挑战最强大脑\n\n#### 题意\n\n初始总值为1，操作1：总值乘X，操作2：总值除第X次出现的乘数。给出每次操作之后总值模72807249之后的值。\n\n#### 分析\n\n1. 除一个以前乘的数，相当于那个数变成了1。\n2. 线段树单点更新，区间查询。\n\n#### 思考\n\n1. 坑点： 区间查询用query会慢，由于是总区间值，直接输出sum[1]就好了。\n2. 技巧： 转换思维。\n\n\n--------\n\n\n\n### G. 线段树写个爽\n\n#### 题意\n\n如题，各式区间更新。\n\n#### 分析\n\n1. 操作1需要全部加上一个值c，最基础的区间标记。\n2. 操作2标记区间左值和右值以及公差\n3. 操作3标记是否转换即可\n4. 操作4，区间查询\n\n#### 思考\n\n1. 坑点： 记得开long long啊，不然WA个爽！另外细节要考虑清楚！\n2. 技巧： 凡是涉及到修改数据的操作，都要标记下传。如果有操作3存在，那么它之前的其它操作都无效。\n\n\n--------\n\n\n### H. 这是一个标题\n\n#### 题意\n\n求区间最大连续和。\n\n#### 分析\n\n1. 三个标记，lsum从左开始的最大和，sum区间最大和，rsum从右开始的最大和。区间合并经典题。\n\n#### 思考\n\n1. 坑点： 无。\n2. 技巧： 设定状态，好好转移。\n\n\n--------\n\n\n### K. 这是一颗普通的树\n\n#### 题意\n\n这是一颗普通的树，普通到需要树链剖分才能解决。\n\n#### 分析\n\n1. 树链剖分之后就是基础的线段树操作了。\n\n#### 思考\n\n1. 坑点： 无。\n2. 技巧： 树链剖分。\n\n\n--------\n\n\n\n\n### L. 数列维护\n\n#### 题意\n\n完成对数列的五种操作。\n\n#### 分析\n\n1. splay。推荐hiho一下 104 周和 105 周的splay专题。\n2. 基于splay的特点，每次都能将需要操作的一段区间旋转到特定子树上，所以操作就好进行了。\n\n#### 思考\n\n1. 坑点： 无。\n2. 技巧： splay。\n\n\n--------\n\n\n\n\n\n### 具体代码点击下方传送门:)\n\n[传送门](https://github.com/GooZy/Codes/tree/master/OJ-CQU/2016%20Pre-summer%20Training%20%E2%85%A3%20-%20Data%20Structure)\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "2016 Pre-summer Training Ⅳ - Data Structure",
        "date": "2016-07-10 10:53:38",
        "tags": [
          "总结",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n### 前言\n数据结构亦可赛艇！我已经中了树的煮粥XD坐等官方题解，学习一波剩下的题Orz 丧病韬面向AC出数据，至今不会那题TAT",
      "fileName": "2016-Pre-summer-Training-Ⅳ-Data-Structure"
    },
    {
      "content": "\n打算有空就做下hihocoder，算是 复习 + 学习 吧 :)\n\n##### [hiho一下第1周——最长回文子串](http://hihocoder.com/contest/hiho1/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC1%E5%91%A8%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2)\n\n##### [hiho一下第2周——Trie树](http://hihocoder.com/contest/hiho2/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC2%E5%91%A8%E2%80%94%E2%80%94Trie%E6%A0%91)\n\n##### [hiho一下第3周——KMP算法](http://hihocoder.com/contest/hiho3/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC3%E5%91%A8%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95)\n<!--more-->\n\n##### [hiho一下第4周——Trie图](http://hihocoder.com/contest/hiho4/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC4%E5%91%A8%E2%80%94%E2%80%94Trie%E5%9B%BE)\n\n##### [hiho一下第5周——数字三角形](http://hihocoder.com/contest/hiho5/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC5%E5%91%A8%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2)\n\n##### [hiho一下第6周——01背包](http://hihocoder.com/contest/hiho6/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC6%E5%91%A8%E2%80%94%E2%80%9401%E8%83%8C%E5%8C%85)\n\n##### [hiho一下第7周——完全背包](http://hihocoder.com/contest/hiho7/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC7%E5%91%A8%E2%80%94%E2%80%94%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85)\n\n##### [hiho一下第8周——状态压缩·一](http://hihocoder.com/contest/hiho8/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC8%E5%91%A8%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%C2%B7%E4%B8%80)\n\n##### [hiho一下第104周——平衡树·Splay](http://hihocoder.com/contest/hiho104/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC104%E5%91%A8%E2%80%94%E2%80%94%E5%B9%B3%E8%A1%A1%E6%A0%91%C2%B7Splay)\n\n##### [hiho一下第105周——平衡树·Splay](http://hihocoder.com/contest/hiho105/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC105%E5%91%A8%E2%80%94%E2%80%94%E5%B9%B3%E8%A1%A1%E6%A0%91%C2%B7Splay2)\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "hiho计划之hiho一下",
        "date": "2016-06-28 13:44:12",
        "tags": [
          "算法"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n打算有空就做下hihocoder，算是 复习 + 学习 吧 :)\n\n##### [hiho一下第1周——最长回文子串](http://hihocoder.com/contest/hiho1/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC1%E5%91%A8%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2)\n\n##### [hiho一下第2周——Trie树](http://hihocoder.com/contest/hiho2/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC2%E5%91%A8%E2%80%94%E2%80%94Trie%E6%A0%91)\n\n##### [hiho一下第3周——KMP算法](http://hihocoder.com/contest/hiho3/problem/1)　　[Code + Note](https://github.com/GooZy/Codes/tree/master/OJ-hihocoder/hiho%E4%B8%80%E4%B8%8B/%E7%AC%AC3%E5%91%A8%E2%80%94%E2%80%94KMP%E7%AE%97%E6%B3%95)",
      "fileName": "hiho计划之hiho一下"
    },
    {
      "content": "\n### 前言\n\n图论专题结束！数据库课设也只剩下小修小补，GJ！总结这次专题：见多识广，建多识广。抓紧在暑假前搞定那本书！\n\n\n<!--more-->\n\n\n### A. Euler\n\n#### 题意\n\n判断一幅图，如果是无向图是否存在欧拉通路，如果是有向图，是否存在欧拉通路\n\n#### 分析\n\n1. 无向图：G 为连通图，并且 G 仅有两个奇度结点（度数为奇数的顶点）或者无奇度结点。\n2. 有向图：D 为有向图， D 的基图连通，并且所有顶点的出度与入度都相等；或者除两个顶点外，其余顶点的出度与入度都相等，而这两个顶点中一个顶点的出度与入度之差为 1，另一个顶点的出度与入度之差为-1。\n\n#### 思考\n\n1. 坑点： 对于孤立点，教材说法不一，导致歧义。\n2. 技巧： 记住判断方法。\n\n\n--------\n\n\n\n### B. -0你电脑炸啦\n\n#### 题意\n\n任务窗口只会在给定的位置出现，需要做的就是判定当前图像是否合法。\n\n#### 分析\n\n1. 图中需要我们找矛盾！\n2. 如果A窗口被B窗口覆盖，那么就连一条边A->B，如果B窗口又被A窗口覆盖，那么连一条边B->A。建完图后，判断是否有环即可判断是否存在矛盾。\n\n#### 思考\n\n1. 坑点： 没有吧，可能原题卡暴力了，然而我没卡= =让大家错失了一次锻炼自己思维的机会啊，23333\n2. 技巧： 建图建图，建多识广。\n\n\n--------\n\n\n\n### C. 寻找fly真迹\n\n#### 题意\n\n构造一个字符串，使得把它的每个字符抽象成点，相邻字符连边能构成题目所给出的图。\n\n#### 分析\n\n1. 注意只有a,b,c三个字符！b字符和任何字符都相连！\n2. 于是，b肯定是度数为n - 1的点。剩下的就是a和c怎么安排了，从点1开始，如果没有被赋予字符就赋予字符a，然后dfs把和a以及任何a所能到的没有赋值的字符赋值为a，因为a能够相邻的只有a和b。完毕后还有字符，那么就赋值c，过程同上。（二分图染色的感觉，最后用构造出来的串比对原图即可）\n\n#### 思考\n\n1. 坑点： 很机智啊。\n2. 技巧： 就看你机智不机智了。\n\n\n--------\n\n\n\n### D. 一食堂 or 二食堂， it's a question\n\n#### 题意\n\n求任意两个人到食堂的距离加上他们两人所在食堂距离之差的和的最大值的最小值。他们间有喜欢/讨厌的关系，使得要/不要在一个食堂用餐。\n\n#### 分析\n\n1. 最大值的最小值，二分既视感。\n2. 知道了答案有什么用呢？可以制造矛盾了。我们定义disA、disB分别为A、B两位同学各自到某个食堂的距离，disAB为两者所在食堂距离，如果disA + disB + disAB > 答案,那么显然这是不可行方案，所以可以推出：A去自己当前选择的这个食堂，B必须去B自己当前选择的另一个；或者B去自己当前选择的这个食堂，A必须去A自己当前选择的另一个；这里只是依据矛盾推出一些东西而已。然后再根据互相喜欢的人建立矛盾，互相讨厌的人建立矛盾。用tarjan判断矛盾是否在一个连通分量内即可。这就是所谓的2-SAT。\n\n#### 思考\n\n1. 坑点： 啊啊啊，我WA 10 发，简直啊！！！对出题人深深地唾弃= =不管怎样，反正他缩点写错了无误，TAT。\n2. 技巧： 找出矛盾，建边，判断连通分量。\n\n\n--------\n\n\n\n### E. Division\n\n#### 题意\n\n不可重点的最小路径覆盖。\n\n#### 分析\n\n1. 缩点，然后二分图匹配。\n2. 二分图中，最小路径覆盖 = 点个数 - 最大匹配数\n\n#### 思考\n\n1. 坑点： 没有。\n2. 技巧： 见多识广。\n\n\n--------\n\n\n### F. meixiuxiu学图论\n\n#### 题意\n\n找图中环上边权最大值的最小值。\n\n#### 分析\n\n1. 啊，我各种缩点，各种GG。\n2. 正解：先最小生成树，标记树上的边。然后不断添加未标记的边，显然，每加入的边必定都会构成环，而由于是最小生成树，所以新加的边一定是环上的最大值，所以拿答案和新加的边不断比较即可。\n\n#### 思考\n\n1. 坑点： 没有。\n2. 技巧： 啊，太美妙了~\n\n\n--------\n\n\n### G. 最短路\n\n#### 题意\n\n统计图中不重边的最短路个数。\n\n#### 分析\n\n1. 不重边呀，所以说每条路径的贡献就是1咯，流啊流啊流的感觉~\n2. 想当初第一次做真是一脸蒙蔽啊= =。正解：跑最短路，把所有最短路的边留下来，然后在新图中最大流即可。\n\n#### 思考\n\n1. 坑点： 没有。\n2. 技巧： 建多识广。\n\n\n--------\n\n\n\n### H. NightMare2\n\n#### 题意\n\n在不爆炸的前提下拿最多的宝藏。\n\n#### 分析\n\n1. 二话没说，感觉可能是先跑最短路，然后根据最短路答案调整的题。写完发现不对，最短路得到的宝藏数和答案没啥关系啊= =然后苦思，结果见2。\n2. 突然问自己，能不能二分？然后就出结果了= =。其实换句话说，就是在规定时间内，从起点到终点最可能经过的最小上限的路能多大？\n3. 二分宝藏价值，然后跑最短路。\n\n#### 思考\n\n1. 坑点： 没有。\n2. 技巧： 转换思维。\n\n\n--------\n\n\n### I. 玛雅，好简单\n\n#### 题意\n\n输出一张无向图中的桥边的数目。\n\n#### 分析\n\n1. 题目太直白了，上tarjan。诶，答案怎么老是不对。啊！按点标记有问题啊TAT，怎么办！怎么办！\n2. “诶，郭**，你看看我这错哪了？”xf如是问我。“诶，你怎么标记边啊。”，对哦，标记边啊！\n\n#### 思考\n\n1. 坑点： 没有。\n2. 技巧： 转换思维。\n\n\n--------\n\n\n### J. An Easy Problem\n\n#### 题意\n\n可重复点的最小路径覆盖。\n\n#### 分析\n\n1. 和E题很像有木有，像归像，然而还是有区别。\n2. 其它和D题一样，不过建立二分图的时候要传递闭包。\n\n#### 思考\n\n1. 坑点： 无。\n2. 技巧： 见多识广。\n\n\n--------\n\n\n### K. 投票\n\n#### 题意\n\n每个人都能给他所能直接或者间接相连的人投一票，问：得票最多的人是几号人物？如果有多个，就按升序输出他们的号码。\n\n#### 分析\n\n1. 缩点得到DAG。得到新图。然后新图中每个点向所有直接或者间接连的点投票，票数为连通块内点个数。最终得票数就是：从其它人那边得到的票数 + 自身连通块内得到票数\n\n#### 思考\n\n1. 坑点： 无。\n2. 技巧： 缩点 + 大胆。\n3. 良心话： 缩点之后，最坏情况O(n^2/2)，就是一条链的情况。所以这种解法理论上还是会T的，好奇正解是啥。\n\n\n--------\n\n\n### L. Cruel War II\n\n#### 题意\n\n能否用不超过10个的点覆盖完整幅图的所有路径。\n\n#### 分析\n\n1. 哦~我百度了一发一般图的最小点集覆盖，找到了一篇论文，实现了它，然后被自己一个五个点的样例叉掉！咦，原来是n^2求近似解啊！！！\n2. fly说搜索，按边搜，意淫半天，终于过了。\n3. 具体就是dfs(p, use)代表到边p，标记了use个点，如果这条边的任意一个点被覆盖了，就继续dfs(p + 1, use)，否则枚举两个点的选与不选。\n\n#### 思考\n\n1. 坑点： 让人以为是NP难题啊！\n2. 技巧： 读题 + 思考。\n\n\n--------\n\n\n### M. interesting\n\n#### 题意\n\n大概就是问无数个a1~an能构成多少个Bmin到Bmax中的数？\n\n#### 分析\n\n1. 我的做法是对这几个数从小到大排序，取最小的非0的数，那么所有能构成的数都能分解成：$0 + k \\times ami, 1 + k \\times ami, ... , ami - 1 + k \\times ami$。然后只需要求出每个剩余结果的最小的那个值是多少就行啦。比如样例，0的最小是0，1的最小是10，2的最小是5。\n2. 然而我WA了= =\n\n#### 思考\n\n1. 。。。。。。。。。。\n\n\n--------\n\n\n\n### 具体代码点击下方传送门:)\n\n[传送门](https://github.com/GooZy/Codes/tree/master/OJ-SCU/CQU%26SCU%20Union%20Training%20III%20-%20Graph%20Theory)\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "Union Training III - Graph Theory",
        "date": "2016-06-07 16:22:19",
        "tags": [
          "总结",
          "图论"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n### 前言\n\n图论专题结束！数据库课设也只剩下小修小补，GJ！总结这次专题：见多识广，建多识广。抓紧在暑假前搞定那本书！",
      "fileName": "Union-Training-III-Graph-Theory"
    },
    {
      "content": "\n### 前言\nDP专题。斜率优化，单调队列，还有各种迷之姿势，反正这个专题我是废了Orz。\n\n<!--more-->\n\n--------\n\n\n### A. 雷神之路\n\n#### 题意\n\n询问从0到n一共有多少种走法，每次可以走1、2、3步，有些点不能走。($1 \\leq n \\leq 10^18$)\n\n#### 分析\n\n1. 很容易想到dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]，然后地雷点dp[i] = 0。\n2. 华丽丽的由于矩阵乘法矩阵位置不对debug了好久。另外一直不知道怎么处理地雷，其实地雷就是原先的矩阵得出的下一个的值为0，那么根据这点构造地雷矩阵即可。\n\n#### 思考\n\n3. 坑点： 无。\n4. 技巧： 使用矩阵快速幂。分A类矩阵、B类矩阵计算。\n\n\n--------\n\n\n\n### C. TaoSama与煎饼\n\n#### 题意\n\n煎饼工作台有($1 \\leq n \\leq 350$)的格子，煎饼通过每个格子会提升口感ai，初始时煎饼在位置1，所以初始口感度为a1。然而煎饼不能自己移动，必须使用Taosama的($1 \\leq m \\leq 120$)个小道具才能移动，每个小道具只能使用一次，每次移动距离bi($1 \\leq bi \\leq 4$)，保证同样距离的小道具总数不超过40。\n\n#### 分析\n\n1. 格子，移动，第一个想法是背包，开搞，答案怎么不对= =额，使用顺序会影响结果啊！ZZ。\n2. 怎么存这顺序呢= =，重新看题目，移动距离1到4，不超过40，关键字啊，新状态dp[i][j][k][l]移动到i使用了第一个、第二个、第三个道具的数量，嗯，第四个相减就能出来嘛~不过这种状态爆内存啊！GG。\n3. 问fly我爆内存了咋办，他说开三维就够了。于是豁然开朗，第一维位置没用啊！然后搞，诶，怎么样例二答案不对= =。左思右想，不对啊，得四维，第四个道具不能由前三个计算出来，算了下不会爆内存，搞！然后AC了~\n\n#### 思考\n\n1. 坑点： 没有吧\n2. 技巧： 正如PPT所说，不管别的，状态开出来再说，优化等开出来后再考虑。\n\n\n--------\n\n\n\n### E. Goozy的积木\n\n#### 题意\n\n用($1 \\leq n \\leq 50$)个积木，最高能搭建多高的两个塔？\n\n#### 分析\n\n1. 这不正是ppt上说的那道题吗？dp[i][j]代表到第i个积木，两塔高度差为j时，最大的共同高度，那么答案就是dp[n][0]了。初始化dp[0][0]为0，其它为负无穷（都是不合法状态）\n2. 转移写了半天，最后自己都搞混了。自己定义的状态没有记清楚，搞得debug了半天。\n\n#### 思考\n\n1. 坑点： 没有。\n2. 技巧： 一定要记得自己状态代表的含义啊！！！$\\times 3$\n\n\n--------\n\n\n\n### H. 又见背包\n\n#### 题意\n\n有($1 \\leq n \\leq 100$)种大小不同的数字a_i,每种($1 \\leq m_i \\leq 10^9$)个，判断是否可以从这些数字中选出若干使它们的和恰好为($1 \\leq k \\leq 10^5$)。\n\n#### 分析\n\n1. 诶！这不是男人八题？！多重背包 + 二进制优化 + bool型dp。\n2. 出题组说二进制优化会被卡！不管了，先写T了再说。结果AC，时间72ms。饿= =。\n\n#### 思考\n\n1. 坑点： 没有。\n2. 技巧： 使用bool型进行转移的话，比起平常调用max函数效率要快不少。另外，本题正解应该是多重背包的单调队列优化，复杂度O(V*N)。然而这种科技就留给fly和xf去吧，2333。\n\n\n--------\n\n\n### L. 来签个到吧\n\n#### 题意\n\n初始有n个球，球上写着数字，第一阶段的任务是让任意两个球上数字之差都在这些球上出现（通过添加球办到），此阶段操作数固定，为放进球的个数；第二阶段需要任意从中抽出球，抽出后放回，直到所有数字都被拿出。问：两阶段的操作数期望值是多少？\n\n#### 分析\n\n1. 第一阶段的任务就是把原始的数列变成等差数列，求公共gcd即可。\n2. 第二阶段要算期望了，默默想到一个状态，dp[i]代表拿到i张卡片的期望操作数，发现无法转移，GG。于是就上网查资料，发现了这个有趣的链接：[传送](http://www.guokr.com/article/5583/)\n\n#### 思考\n\n1. 坑点： 数列中的值存在0，此时不能把0考虑进入gcd。\n2. 技巧： 说好的dp呢？转移呢？怎么就变成解数学期望题了！！！把取到第i个数的平均次数相加就是期望次数，果然高中到现在，还是觉得概率啊，期望啊这种东西太迷了。\n\n\n--------\n\n\n\n### 具体代码点击下方传送门:)\n\n[传送门](https://github.com/GooZy/Codes/tree/master/OJ-SCU/CQU%26SCU%20Union%20Training%20II%20-%20Dynamic%20Programming)\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "CQU&SCU Union Training II - Dynamic Programming",
        "date": "2016-05-23 13:36:56",
        "tags": [
          "总结",
          "动态规划"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n### 前言\nDP专题。斜率优化，单调队列，还有各种迷之姿势，反正这个专题我是废了Orz。",
      "fileName": "CQU-SCU-Union-Training-II-Dynamic-Programming"
    },
    {
      "content": "\n### 前言\n\n为期10天的第一次训练结束~ 时间好快。学到了好多知识~ 不过后缀数组还是不敢碰呀，算是这个专题的一个小遗憾吧。\n\n<!--more-->\n\n\n--------\n\n\n### A. 双剑合并\n\n#### 题意\n\n从两个大小最大为1e6的数组中分别找出一个数，使得这两个数的异或和最大。\n\n#### 分析\n\n1. 1e6啊，暴力肯定不行了。把其中一个数组中的数字看成二进制，相当于是查找另一个数组中能把这个数中高位0位填了的数中效益最大的那个数。怎么查询呢？\n2. 于是我试着二分查询补码，结果：GG。\n\n#### 思考\n\n3. 坑点： 无。\n4. 技巧： 将其中一个数组建立成trie树，然后另一个数组中的数在其中查询。注意：建树要从二进制位的高位往低位建树，查询同理。这样才能保证异或和最大。\n\n\n--------\n\n\n### B. 单词替换\n\n#### 题意\n\n将一个长度最长为5e6的字符串中的单词A替换成单词B，输出替换后的字符串。\n\n#### 分析\n\n1. 单词替换，kmp匹配即可。\n\n#### 思考\n\n2. 坑点： 使用strlen多次计算长度，可能导致TLE。\n3. 技巧： 在kmp匹配的时候，当模式串匹配成功后，不用退出，接着匹配。一边匹配一边输出答案。\n\n\n--------\n\n\n\n### C. 01的时间\n\n#### 题意\n\n输出不超过466的正整数由0和1构成的最小倍数。\n\n#### 分析\n\n1. 从1开始bfs，每次优先放0，接着放1，用char来存答案。\n2. 没有标记，直接MLE。\n\n#### 思考\n\n3. 坑点： 1)本题会爆long long，但是不会爆unsigned long long。2)bfs不标记会MLE。\n4. 技巧： 考虑一个很长的数字(长度>100)，需要问这个数能否被某个数整除，我们可以直接从左往右解析这个数字，一边解析一边取模。本题可以借鉴这种做法，将模作为状态来标记，所以整个搜索空间最多466。每次取出数字优先添加0，之后添加1即可。\n\n\n--------\n\n\n\n### D. GooZy的游戏时间\n\n#### 题意\n\n将小正方形进行平移，使得最终构成一个大正方形，并且两正方形邻接的三角形上数字相同。有解输出Possible，无解Impossible。最多25个小正方形。\n\n#### 分析\n\n1. 暴力查找\n2. TLE\n\n#### 思考\n\n3. 坑点： 会出现24个全都相同的矩形，搜索空间爆炸。\n4. 技巧： 将相同的矩形预处理在一起，当前位置该矩形不行，那么其它所有和这个矩形一样的矩形也一定不能放在这个位置。\n5. 神之样例（还不知道怎么剪枝能过）<由fly提供>：  \n1  \n5  \n1 1 1 1  \n1 1 2 1  \n1 1 3 1  \n1 1 4 1  \n1 1 6 1  \n2 1 1 1  \n2 1 2 1  \n2 1 3 1  \n2 1 4 1  \n2 1 6 1  \n3 1 1 1  \n3 1 2 1  \n3 1 3 1  \n3 1 4 1  \n3 1 6 1  \n4 1 1 1  \n4 1 2 1  \n4 1 3 1  \n4 1 4 1  \n4 1 6 1  \n5 1 1 1  \n5 1 2 1  \n5 1 3 1  \n5 1 4 1  \n5 1 6 1\n\n\n--------\n\n\n\n### E. RunningPhoton's Nightmare\n\n#### 题意\n\n在一个$600 \\times 600$的图中，需要从S点走到E点，但是有个计时器在计时，超过($\\geq k$)就会爆炸，中间有R点，可以重置计时器时间为0，问能否走到E点？\n\n#### 分析\n\n1. bfs。结构体中存放当前的位置x和y，以及走了dis的时间，另开一个全局数组dis[i][j]记录到达点(i,j)炸弹的时间。每次向炸弹时间比该处小就能转移。\n\n#### 思考\n\n2. 坑点： 刚开始标程神之T++，算不算坑点，23333\n3. 技巧： 可以预处理起始点、终点、R点的最短距离，跑一遍最短路即可。（然而我没预处理直接bfs也过了= =。）\n\n\n--------\n\n\n\n### F. 表达式\n\n#### 题意\n\n初始只有x，可以用已有的值对当前值进行乘或者除，问：到达$x^n$需要的最少步骤是几步？($n \\leq 1000)$\n\n#### 分析\n\n1. 贪心啊，每次倍增！嗯，就是这么搞。\n2. 结果是WA。\n\n#### 思考\n\n3. 坑点： 没有，953这个样例很友好地给了出来。\n4. 技巧： 迭代加深搜索，枚举深度。一个强力剪枝：当当前最大可能值在之后一直自乘，都无法到达n，就可以返回。\n\n\n--------\n\n\n\n### G. 神舟的宝藏\n\n#### 题意\n\n用给定的进制和数，构成N的最小倍数。\n\n#### 分析\n\n1. 这不是进阶版的C题吗？\n\n#### 思考\n\n2. 坑点： 无。\n3. 技巧： 抓住状态空间，用char数组存答案。其它同C题。\n\n\n--------\n\n\n\n### H. DNA序列\n\n#### 题意\n\n构造一个DNA序列，使得其子序列能够组成给出的N个DAN序列中的任意一个。($N \\leq 8, 长度 \\leq 5$)\n\n#### 分析\n\n1. 迭代加深试试。\n2. 剪枝不够强力T了。\n\n#### 思考\n\n3. 坑点： 剪枝不强，AAAAA，CCCCC，GGGGG，TTTTT这个样例是过不了的。\n4. 技巧： 首先，当某个串还差X才能构造出来，然而剩余深度小于X，那么可以肯定这之后就不用访问了，这是小剪枝。其次，用来构造的字符一定要是这N个串中所拥有的，否则加了白加，小剪枝。最后，每次统计所有串中，单串最长的A次数、C次数、G次数、T次数，他们的和就是需要构成的串至少需要的长度，这样倒着建立串，就能根据这个强力剪枝！\n\n\n--------\n\n\n\n### I. 小冰和小娜\n\n#### 题意\n\n问：能否从起点到达终点，使得车轮的颜色起点和终点一样？能输出最少时间，否则-1。（车轮有五种颜色，每次转向或者前行消耗一个时间，移动一次变换一次颜色。）\n\n#### 分析\n\n1. bfs，开四维数组记录到达点(x,y)方向为z，颜色为c所需要的最少时间。\n\n#### 思考\n\n2. 坑点： 转向和前行都得消耗时间。\n3. 技巧： 老老实实写BFS即可。\n\n\n--------\n\n\n\n### J. TooEasy Or TooDifficult\n\n#### 题意\n\n求字符串最长回文串，求区间最大异或和。\n\n#### 分析\n\n1. 最长回文串easy，manacher即可。异或和没想法。\n\n#### 思考\n\n2. 坑点： MZ的次方数好可怕，以为不能用快速幂搞定Orz。\n3. 技巧： 区间异或和可以转换为从0开始区间连续的异或和，变成一个值，两个这样的值异或，就是它们的非公共区间异或和了。所以我们用trie来存异或值，这样就变成了求两个数的最大异或和，套用A题思路即可。\n\n\n--------\n\n\n\n### K. 奶牛合影\n\n#### 题意\n\n求长度最大为3e5的环上，哪个点开始，字典序最小。\n\n#### 分析\n\n1. 典型的最小表示法呀。\n\n#### 思考\n\n2. 坑点： 无。\n3. 技巧： 会最小表示法就OK啦。\n\n\n--------\n\n\n\n### M. 奶牛硬盘\n\n#### 题意\n\n用1000进位和1024进位来计算内存，所少计算的百分率是多少？最大到YB。\n\n#### 分析\n\n1. 数字相除，数字部分没用啊，那答案不就是固定的？来来来，打表。嗯，对了，特判0。\n2. 标程没有特判0，所以你特判就是错的。\n\n#### 思考\n\n3. 坑点： 标程错了= =\n4. 技巧： 不打表的话，只需每次记录下1000和1024的比率，根据单位乘就能得到结果了。\n\n\n--------\n\n\n\n### N. 奶牛情书\n\n#### 题意\n\n给出不多于60个单词，长度不超过100，求至少包含其中一个单词，长度为M($M \\leq 100$)的文本的构造方式有多少种？\n\n#### 分析\n\n1. 好难= =。后来看挑战知道是字符串dp，需要自动机预处理。\n2. 没有考虑ABA CCCCCCABAC这种情况下，第二个字符串中包含了需要出现的串ABA，而我们的做法是：答案 = 所有可能情况 - 不可能情况，所以这里需要对fail数组处理一下。\n\n#### 思考\n\n3. 坑点： 串中还会包含串。\n4. 技巧： 用自动机预处理每个前缀能够到达的转移，在构建fail数组时，如果当前字符串的fail是禁止串，那么当前串也要标为禁止串。然后$dp[i + 1][nxt[j][k]] = dp[i][j]$ ; (nxt[j][k]即：第j个前缀加上第k个字符后能够转移到的前缀)\n\n\n--------\n\n\n\n### 具体代码点击下方传送门:)\n\n[传送门](https://github.com/GooZy/Codes/tree/master/OJ-SCU/CQU%26SCU%20Union%20Training%20I%20-%20Searching%20and%20Strings)\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "CQU&SCU Union Training I - Searching and Strings",
        "date": "2016-05-10 20:31:59",
        "tags": [
          "总结"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n### 前言\n\n为期10天的第一次训练结束~ 时间好快。学到了好多知识~ 不过后缀数组还是不敢碰呀，算是这个专题的一个小遗憾吧。",
      "fileName": "CQU-SCU-Union-Training-I-Searching-and-Strings"
    },
    {
      "content": "\n<font color=\"#6495ED\">**题目链接：**</font>\n[HDU 1824 Let's go home (2-SAT)](http://acm.hdu.edu.cn/showproblem.php?pid=1824)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \nn支队伍，m个关系。满足：1.队伍里面，队长和其余两名队员两者中必须有一个要留下来；2.关系中，A队员留下B队员就得离开，B队员留下，A队员就要离开。问：能否合理安排满足以上两个关系。\n<!--more-->\n\n<font color=\"#6495ED\">**解题思路：**</font>  \n将每个点拆分成两种状态：留下和不留下，然后根据题目，设：A为队长，B和C为队员，那么就有!A->(B^C), (!Bv!C)->A, 然后每个关系中，有：B->!C, C->!B. 最终根据关系建边，判断矛盾关系是否在同一个连通分量内即可。  \n2-SAT类型的题，重要的就在于把这些对象间的关系理清楚。\n\n<font color=\"#6495ED\">**个人感受：**</font>  \n这题充分考验了ACMer的语文水平，唉唉唉。\n\n<font color=\"#6495ED\">**具体代码如下：**</font>\n\n```c++\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#define ll long long\n#define pr(x) cout << #x << \" = \" << (x) << '\\n';\nusing namespace std;\n\nconst int INF = 0x7f7f7f7f;\nconst int MAXN = 6e3 + 111;\n\nvector<int> G[MAXN];\nint n, m;\nint dfn[MAXN], low[MAXN], sta[MAXN], id[MAXN], indx, scc, top;\nbool in[MAXN];\n\nvoid init() {\n    for (int i = 0; i <= 6 * n; ++i) {\n        G[i].clear();\n        in[i] = 0;\n        dfn[i] = 0;\n    }\n    indx = scc = top = 0;\n}\n\nvoid tarjan(int u) {\n    dfn[u] = low[u] = ++indx;\n    sta[top++] = u;\n    in[u] = 1;\n    for (int i = 0; i < G[u].size(); ++i) {\n        int v = G[u][i];\n        if (!dfn[v]) {\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n        }\n        else if (in[v]) low[u] = min(low[u], dfn[v]);\n    }\n\n    if (dfn[u] == low[u]) {\n        ++scc;\n        int v;\n        do {\n            v = sta[--top];\n            in[v] = 0;\n            id[v] = scc;\n        } while (v != u);\n    }\n}\n\nint main()\n{\n    int a, b, c;\n    while (~scanf(\"%d%d\", &n, &m)) {\n        init();\n        int add = 3 * n;\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%d%d%d\", &a, &b, &c);\n            G[a + add].push_back(c);\n            G[a + add].push_back(b);\n            G[b + add].push_back(a);\n            G[c + add].push_back(a);\n        }\n        int u, v;\n        while (m --) {\n            scanf(\"%d%d\", &u, &v);\n            G[u].push_back(v + add);\n            G[v].push_back(u + add);\n        }\n\n        for (int i = 0; i < 6 * n; ++i) {\n            if (!dfn[i]) tarjan(i);\n        }\n\n        bool flag = 1;\n        for (int i = 0; i < 3 * n; ++i) {\n            if (id[i] == id[i + 3 * n]) {\n                flag = 0;\n                break;\n            }\n        }\n        printf(\"%s\\n\", flag? \"yes\" : \"no\");\n    }\n    return 0;\n}\n\n```\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "HDU 1824 Let's go home (2-SAT)",
        "date": "2016-04-25 20:47:38",
        "tags": [
          "tarjan",
          "2-SAT"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n<font color=\"#6495ED\">**题目链接：**</font>\n[HDU 1824 Let's go home (2-SAT)](http://acm.hdu.edu.cn/showproblem.php?pid=1824)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \nn支队伍，m个关系。满足：1.队伍里面，队长和其余两名队员两者中必须有一个要留下来；2.关系中，A队员留下B队员就得离开，B队员留下，A队员就要离开。问：能否合理安排满足以上两个关系。",
      "fileName": "HDU-1824-Let-s-go-home-2-SAT"
    },
    {
      "content": "\n<font color=\"#6495ED\">**题目链接：**</font>\n[HDU 3966 Aragorn's Story (树链剖分,线段树)](http://acm.hdu.edu.cn/showproblem.php?pid=3966)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \n有三种操作，操作I：增加一个区间中结点的值；操作D：减少一个区间中结点的值；操作Q：查询结点值。\n<!--more-->\n\n<font color=\"#6495ED\">**解题思路：**</font>  \n将整棵树剖分成链，用线段树来维护。——树链剖分。  \n树链剖分巧妙地将同一条重链安排在了一起，这样变成一条总链的时候，只需要一条一条重链地更新或者查询就行了。具体还是建议上网找份PPT看。\n\n<font color=\"#6495ED\">**个人感受：**</font>  \nRE->WA->AC。RE应该是和lazy数组更新有关，后期WA是因为区间更新写错了。不过如今真得觉得线段树不难呀，以前要死要活的，哈哈\n\n<font color=\"#6495ED\">**具体代码如下：**</font>\n\n```c++\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#define ll long long\n#define pr(x) cout << #x << \" = \" << (x) << '\\n';\nusing namespace std;\n\nconst int INF = 0x7f7f7f7f;\nconst int MAXN = 5e4 + 111;\nconst int MAXM = 1e5 + 111;\n\nstruct Edge {\n    int to, next;\n}edge[MAXM];\nint head[MAXN];\n// 它们分别是：深度，重儿子，儿子数，链顶端，父亲节点，在数组中位置，位置代表的节点\nint dep[MAXN], son[MAXN], num[MAXN], top[MAXN], fa[MAXN], p[MAXN], fp[MAXN];\nint enemy[MAXN];\nint pos, tol;\n\nvoid init(int n) {\n    for (int i = 1; i <= n; ++i) {\n        son[i] = head[i] = -1;\n    }\n    pos = tol = 0;\n}\n\nvoid addedge(int u, int v) {\n    edge[tol].to = v, edge[tol].next = head[u], head[u] = tol++;\n}\n\nvoid dfs1(int u, int pre, int d) {\n    dep[u] = d;\n    fa[u] = pre;\n    num[u] = 1;\n    for (int i = head[u]; ~i; i = edge[i].next) {\n        int v = edge[i].to;\n        if (v != pre) {\n            dfs1(v, u, d + 1);\n            num[u] += num[v];\n            if (son[u] == -1 || num[son[u]] < num[v]) {\n                son[u] = v;\n            }\n        }\n    }\n}\n\nvoid dfs2(int u, int f) {\n    p[u] = ++pos;\n    top[u] = f;\n    fp[p[u]] = u;\n    if (son[u] == -1) return;\n    dfs2(son[u], f);\n    for (int i = head[u]; ~i; i = edge[i].next) {\n        int v = edge[i].to;\n        if (v != son[u] && v != fa[u])\n            dfs2(v, v);\n    }\n}\n\nstruct Node {\n    int l, r, lazy;\n}st[MAXN << 2];\n\nvoid build(int l, int r, int rt) {\n    st[rt].l = l;\n    st[rt].r = r;\n    st[rt].lazy = 0;\n    if (l == r) {\n        return;\n    }\n    int m = (l + r) >> 1;\n    build(l, m, rt << 1);\n    build(m + 1, r, rt << 1 | 1);\n}\n\nvoid pushdown(int rt) {\n    if (st[rt].lazy != 0) {\n        st[rt << 1].lazy += st[rt].lazy;\n        st[rt << 1 | 1].lazy += st[rt].lazy;\n        st[rt].lazy = 0;\n    }\n}\n\nint query(int rt, int val) {\n    if (st[rt].l == st[rt].r) return st[rt].lazy;\n    pushdown(rt);\n    int m = (st[rt].l + st[rt].r) >> 1;\n    if (val <= m) return query(rt << 1, val);\n    else return query(rt << 1 | 1, val);\n}\n\nvoid update(int L, int R, int w, int rt) {\n    int l = st[rt].l, r = st[rt].r;\n    if (L <= l && r <= R) {\n        st[rt].lazy += w;\n        return;\n    }\n    pushdown(rt);\n    int m = (l + r) >> 1;\n    if (L <= m) update(L, R, w, rt << 1);\n    if (m < R) update(L, R, w, rt << 1 | 1);\n}\n\nvoid change(int u, int v, int w) {\n    while (top[u] != top[v]) { // 慢慢向重链靠近\n        if (dep[top[u]] < dep[top[v]]) swap(u, v);\n        update(p[top[u]], p[u], w, 1);\n        u = fa[top[u]];\n    }\n    if (dep[u] > dep[v]) swap(u, v);\n    update(p[u], p[v], w, 1);\n}\n\nint main()\n{\n    int n, m, q, u, v, w;\n    while (~scanf(\"%d%d%d\", &n, &m, &q)) {\n        init(n);\n        for (int i = 1; i <= n; ++i) scanf(\"%d\", &enemy[i]);\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%d%d\", &u, &v);\n            addedge(u, v);\n            addedge(v, u);\n        }\n\n        dfs1(1, 0, 0);\n        dfs2(1, 1);\n        build(1, pos, 1);\n\n        char op[2];\n        while (q--) {\n            scanf(\"%s\", op);\n            if (op[0] == 'Q') {\n                scanf(\"%d\", &u);\n                printf(\"%d\\n\", enemy[u] + query(1, p[u]));\n            }\n            else {\n                scanf(\"%d%d%d\", &u, &v, &w);\n                if (op[0] == 'D') w = -w;\n                change(u, v, w);\n            }\n        }\n    }\n    return 0;\n}\n\n```\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "HDU 3966 Aragorn's Story (树链剖分,线段树)",
        "date": "2016-04-23 18:12:23",
        "tags": [
          "树链剖分",
          "线段树"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n<font color=\"#6495ED\">**题目链接：**</font>\n[HDU 3966 Aragorn's Story (树链剖分,线段树)](http://acm.hdu.edu.cn/showproblem.php?pid=3966)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \n有三种操作，操作I：增加一个区间中结点的值；操作D：减少一个区间中结点的值；操作Q：查询结点值。",
      "fileName": "HDU-3966-Aragorn-s-Story-树链剖分-线段树"
    },
    {
      "content": "\n<font color=\"#6495ED\">**题目链接：**</font>\n[ZJU 1008 Gnome Tetravex (DFS)](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1008)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \n给出$N \\times N$块正方形，每一块被切割成上下左右四个三角形，每个三角形写上0~9的值，问：能否移动这些正方形的位置，使得它们排列成$N \\times N$的方块，每一个相邻的边上数字都相同。\n<!--more-->\n\n<font color=\"#6495ED\">**解题思路：**</font>  \n从第一个方块开始枚举，还必须加上必要的剪枝，比如规格相同的方块在同一个地方不可行一次就不用试第二次了。\n\n<font color=\"#6495ED\">**个人感受：**</font>  \n啊啊啊，剪枝想不到啊啊啊啊啊。。。\n\n<font color=\"#6495ED\">**具体代码如下：**</font>  \n\n```c++\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#define pr(x) cout << #x << \" = \" << (x) << '\\n';\nusing namespace std;\n\nstruct Square {\n    int u, r, d, l;\n}sq[30];\nint mp[10][10], sum[30];\nint n, ed;\n\nbool dfs(int p) {\n    if (p == ed) {\n        return 1;\n    }\n\n    int x = p / n, y = p % n;\n    for (int i = 0; i < ed; ++i) {\n        if (!sum[i]) continue;\n        if (x > 0 && sq[mp[x - 1][y]].d != sq[i].u) continue;\n        if (y > 0 && sq[mp[x][y - 1]].r != sq[i].l) continue;\n        mp[x][y] = i;\n        --sum[i];\n        if (dfs(p + 1)) return 1;\n        ++sum[i];\n    }\n    return 0;\n}\n\nint main()\n{\n    int kase = 0;\n    while (~scanf(\"%d\", &n) && n) {\n        ed = n * n;\n        for (int i = 0; i < ed; ++i) {\n            sum[i] = 0;\n            scanf(\"%d%d%d%d\", &sq[i].u, &sq[i].r, &sq[i].d, &sq[i].l);\n            bool flag = 1;\n            for (int j = 0; j < i; ++j) {\n                if (sq[i].u == sq[j].u && sq[i].r == sq[j].r\n                    && sq[i].d == sq[j].d && sq[i].l == sq[j].l) {\n                    ++sum[j];\n                    flag = 0;\n                    break;\n                }\n            }\n            if (flag) sum[i] = 1;\n        }\n\n        if (kase) putchar('\\n');\n        if (dfs(0)) printf(\"Game %d: Possible\\n\", ++kase);\n        else printf(\"Game %d: Impossible\\n\", ++kase);\n    }\n    return 0;\n}\n\n```\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "ZJU 1008 Gnome Tetravex (DFS)",
        "date": "2016-04-20 14:00:49",
        "tags": [
          "DFS"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n<font color=\"#6495ED\">**题目链接：**</font>\n[ZJU 1008 Gnome Tetravex (DFS)](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1008)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \n给出$N \\times N$块正方形，每一块被切割成上下左右四个三角形，每个三角形写上0~9的值，问：能否移动这些正方形的位置，使得它们排列成$N \\times N$的方块，每一个相邻的边上数字都相同。",
      "fileName": "ZJU-1008-Gnome-Tetravex-dfs"
    },
    {
      "content": "\n<font color=\"#6495ED\">**题目链接：**</font>\n[POJ 2763 Housewife Wind (LCA,RMQ,BIT)](http://acm.pku.edu.cn/JudgeOnline/problem?id=2763)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \n给出两个操作，0：妈妈需要到树上某个结点接孩子，每次输出最短距离，然后妈妈的位置变成孩子所在的位置。1：更改树上某条边的距离为w。\n<!--more-->\n\n<font color=\"#6495ED\">**解题思路：**</font>  \n由于每次移动都会使得母亲的位置变动，这里我们需要使用LCA的在线算法。  \n首先，我们将整棵树根据后序遍历拉成一条链，每次记录这个链上结点代表的结点是什么(vs[i])和深度是多少(dep[i])，顺便记录这个结点第一次出现的时候是在链上什么位置(id[i])。然后每次$lca(a,b)$其实就是查询$[id[a],id[b]]$这个区间内，dep最小的那个下标是什么。  \n其次，由于本题涉及到更新操作，如上我们已经把它拉成一条链了，所以下一步只需在父亲指向儿子的边加权值，儿子指向父亲的边减权值，然后查询区间$$sum(id[a])+sum(id[b])-2 \\times sum(id[lca(a,b)])$$即可。\n\n<font color=\"#6495ED\">**个人感受：**</font>  \n爽呆了这题，为了A这题，A了两道RMQ，复习了BIT，爽23333\n\n<font color=\"#6495ED\">**具体代码如下：**</font>\n\n```c++\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\nusing namespace std;\n\nconst int MAXN = 1e5 + 111;\n\nstruct Edge {\n    int to, id, w, next;\n}edge[MAXN * 2];\nint head[MAXN], tol;\n\nvoid addedge(int u, int v, int id, int w) {\n    edge[tol].to = v; edge[tol].w = w; edge[tol].id = id;\n    edge[tol].next = head[u]; head[u] = tol++;\n}\n\nint s, bitn;\nint w[MAXN];\nvector<Edge> G[MAXN];\n\nint id[MAXN], es[MAXN * 2], dep[MAXN * 2], vs[MAXN * 2];\nint bit[MAXN * 2], dp[MAXN * 2][20];\n\nvoid add(int i, int x) {\n    while (i <= bitn) {\n        bit[i] += x;\n        i += lowbit(i);\n    }\n}\n\nint sum(int i) {\n    int ret = 0;\n    while (i > 0) {\n        ret += bit[i];\n        i -= lowbit(i);\n    }\n    return ret;\n}\n\nvoid dfs(int u, int p, int sum, int &k) {\n    id[u] = k;\n    vs[k] = u;\n    dep[k++] = sum;\n    for (int i = head[u]; ~i; i = edge[i].next) {\n        Edge &e = edge[i];\n        if (e.to != p) {\n            add(k, e.w);\n            es[e.id * 2] = k;\n            dfs(e.to, u, sum + e.w, k);\n            vs[k] = u;\n            dep[k++] = sum;\n            add(k, -e.w);\n            es[e.id * 2 + 1] = k;\n        }\n    }\n}\n\nint my_min(int a, int b) {\n    return dep[a] <= dep[b] ? a : b;\n}\n\nvoid init_rmq(int n) {\n    for (int i = 0; i <= n; ++i) dp[i][0] = i;\n    for (int j = 1; j < 20; ++j) {\n        for (int i = 0; i + (1 << j) - 1 <= n; ++i) {\n            dp[i][j] = my_min(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);\n        }\n    }\n}\n\nvoid init(int n) {\n    bitn = n * 2 - 1;\n    memset(bit, 0, sizeof bit);\n    int k = 0;\n    dfs(0, -1, 0, k);\n    init_rmq(2 * n - 1);\n}\n\nint query(int l, int r) {\n    int k = log2(r - l + 1);\n    return my_min(dp[l][k], dp[r - (1 << k) + 1][k]);\n}\n\nint lca(int a, int b) {\n    if (id[a] > id[b]) swap(a, b);\n    return vs[query(id[a], id[b])];\n}\n\nint main()\n{\n    int n, q, u, v;\n    while (~scanf(\"%d%d%d\", &n, &q, &s)) {\n        for (int i = 0; i < n; ++i) G[i].clear(), head[i] = -1;\n        tol = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            scanf(\"%d%d%d\", &u, &v, &w[i]);\n            --u, --v;\n            addedge(u, v, i, w[i]);\n            addedge(v, u, i, w[i]);\n        }\n\n        init(n);\n\n        int op, a, b;\n        --s;\n        for (int i = 0; i < q; ++i) {\n            scanf(\"%d%d\", &op, &a);\n            --a;\n            if (op == 0) {\n                int p = lca(s, a);\n                printf(\"%d\\n\", sum(id[s]) + sum(id[a]) - 2 * sum(id[p]));\n                s = a;\n            }\n            else {\n                scanf(\"%d\", &b);\n                add(es[2 * a], b - w[a]);\n                add(es[2 * a + 1], w[a] - b);\n                w[a] = b;\n            }\n        }\n    }\n    return 0;\n}\n\n```\n\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "POJ 2763 Housewife Wind (LCA,RMQ,BIT)",
        "date": "2016-04-17 13:08:31",
        "tags": [
          "LCA",
          "RMQ",
          "BIT"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n<font color=\"#6495ED\">**题目链接：**</font>\n[POJ 2763 Housewife Wind (LCA,RMQ,BIT)](http://acm.pku.edu.cn/JudgeOnline/problem?id=2763)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \n给出两个操作，0：妈妈需要到树上某个结点接孩子，每次输出最短距离，然后妈妈的位置变成孩子所在的位置。1：更改树上某条边的距离为w。",
      "fileName": "POJ-2763-Housewife-Wind-LCA-RMQ-BIT"
    },
    {
      "content": "\n<font color=\"#6495ED\">**题目链接：**</font>\n[POJ 1426 Find The Multiple (BFS)](http://acm.pku.edu.cn/JudgeOnline/problem?id=1426)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \n给出一个数字n，查找一个只由0和1构成的数字，使得这个数字能够整除n。输出一个这样的数字。\n<!--more-->\n\n<font color=\"#6495ED\">**解题思路：**</font>  \n首先第一个数肯定是1，然后不断得枚举添加0或者1，用BFS进行搜索即可。这里要注意两点：  \n1.长度很大的数字取余数可以使用从左到右解析的方式，所以每一次我们保留下解析后的余数即可，然后使用余数作为标记。  \n2.这就要求我们需要另开一个数组来存答案，所以BFS里面存的是结构体。\n\n<font color=\"#6495ED\">**个人感受：**</font>  \n不知道POJ上面那些肯定long long能存的下的人结论是哪里来的。想到了余数计算就行，却没想到怎么标记，加油~\n\n<font color=\"#6495ED\">**具体代码如下：**</font>\n\n```c++\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#define lowbit(x) (x & (-x))\n#define ll long long\n#define pr(x) cout << #x << \" = \" << (x) << '\\n';\nusing namespace std;\n\nstruct P {\n    char ans[111];\n    int cnt;\n    int mod;\n};\nbool vis[311];\n\nint main()\n{\n    int n;\n    while (~scanf(\"%d\", &n) && n) {\n        queue<P> q;\n        memset(vis, 0, sizeof vis);\n        P st;\n        st.cnt = 1;\n        st.ans[0] = '1';\n        st.mod = 1 % n;\n        q.push(st);\n\n        while (q.size()) {\n            P cur = q.front(); q.pop();\n            if (cur.mod == 0) {\n                for (int i = 0; i < cur.cnt; ++i) printf(\"%c\", cur.ans[i]);\n                putchar('\\n');\n                break;\n            }\n            vis[cur.mod] = 1;\n\n            cur.cnt = cur.cnt + 1;\n            cur.ans[cur.cnt - 1] = '0';\n            cur.mod = (cur.mod * 10) % n;\n            if (!vis[cur.mod])\n                q.push(cur);\n            cur.ans[cur.cnt - 1] = '1';\n            cur.mod = (cur.mod + 1) % n;\n            if (!vis[cur.mod])\n                q.push(cur);\n        }\n    }\n    return 0;\n}\n\n```\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "POJ 1426 Find The Multiple (BFS)",
        "date": "2016-04-17 13:01:46",
        "tags": [
          "BFS"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n<font color=\"#6495ED\">**题目链接：**</font>\n[POJ 1426 Find The Multiple (BFS)](http://acm.pku.edu.cn/JudgeOnline/problem?id=1426)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \n给出一个数字n，查找一个只由0和1构成的数字，使得这个数字能够整除n。输出一个这样的数字。",
      "fileName": "POJ-1426-Find-The-Multiple-BFS"
    },
    {
      "content": "\n<font color=\"#6495ED\">**题目链接：**</font>\n[POJ 3264 Balanced Lineup (RMQ,ST)](http://acm.pku.edu.cn/JudgeOnline/problem?id=3264)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \n询问区间$[L,R]$最大值和最小值的差值为多少?\n<!--more-->\n\n<font color=\"#6495ED\">**解题思路：**</font>  \nRMQ的ST算法登场。$dpl[i][j]$代表：从第i个数开始，包含第i个数，区间长度为$2^j$范围内的最小值。有转移：$$dpl[i][j] = min(dp[i][j - 1], dp[i + 2^{j - 1}][j - 1])$$\n$dph[i][j]$同理。  \n最终求区间中的最小值，那么我们只需查询:  \n$k = log_2(r - l + 1)$  \n$ans = min(dpl[i][k], dpl[i + (1 << k) + 1][k])$\n\n<font color=\"#6495ED\">**个人感受：**</font>  \n头一次写ST算法，原来也不难啊......以前以为很复杂Orz\n\n<font color=\"#6495ED\">**具体代码如下：**</font>\n```c++\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#define lowbit(x) (x & (-x))\n#define ll long long\n#define pr(x) cout << #x << \" = \" << (x) << '\\n';\nusing namespace std;\n\nconst int INF = 0x7f7f7f7f;\nconst int MAXN = 5e4 + 111;\n\nint dpl[MAXN][20], dph[MAXN][20], a[MAXN];\n\nint getMax(int l, int r) {\n    int k = log2(r - l + 1);\n    return max(dph[l][k], dph[r - (1 << k) + 1][k]);\n}\n\nint getMin(int l, int r) {\n    int k = log2(r - l + 1);\n    return min(dpl[l][k], dpl[r - (1 << k) + 1][k]);\n}\n\nint main()\n{\n    int n, q;\n    while (~scanf(\"%d%d\", &n, &q)) {\n        for (int i = 1; i <= n; ++i) {\n            scanf(\"%d\", &a[i]);\n            dpl[i][0] = dph[i][0] = a[i];\n        }\n\n        for (int j = 1; j < 20; ++j) {\n            for (int i = 1; i <= n; ++i) {\n                if (i + (1 << j) - 1 <= n) {\n                    dpl[i][j] = min(dpl[i][j - 1], dpl[i + (1 << (j - 1))][j - 1]);\n                    dph[i][j] = max(dph[i][j - 1], dph[i + (1 << (j - 1))][j - 1]);\n                }\n                else break;\n            }\n        }\n\n        int l, r;\n        for (int i = 0; i < q; ++i) {\n            scanf(\"%d%d\", &l, &r);\n            printf(\"%d\\n\", getMax(l, r) - getMin(l, r));\n        }\n    }\n    return 0;\n}\n\n```\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "POJ 3264 Balanced Lineup (RMQ,ST)",
        "date": "2016-04-16 10:37:59",
        "tags": [
          "RMQ",
          "ST"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n<font color=\"#6495ED\">**题目链接：**</font>\n[POJ 3264 Balanced Lineup (RMQ,ST)](http://acm.pku.edu.cn/JudgeOnline/problem?id=3264)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \n询问区间$[L,R]$最大值和最小值的差值为多少?",
      "fileName": "POJ-3264-Balanced-Lineup-RMQ-ST"
    },
    {
      "content": "\n<font color=\"#6495ED\">**题目链接：**</font>[ZJU 2760 How Many Shortest Path (最大流)](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2760)\n\n<font color=\"#6495ED\">**题意分析：**</font>\n\n求从指定点到指定点的没有重边的最短路个数。如果起点终点相同，则输出“inf”。\n<!--more-->\n\n<font color=\"#6495ED\">**解题思路：**</font>\n\n将最短路上的所有边都保留下来，求最大流即可。注意：本题i == j 时，不一定矩阵就是0，坑爹啊。\n\n<font color=\"#6495ED\">**个人感受：**</font>\n\n首先是我一直以为流量为0输出inf，没想到这样判断就T成傻逼。。。。。还以为是floyd的锅！通过此，又对自己的板子加深了理解XD。mp[i][i]不一定为0也是醉了。\n\n<font color=\"#6495ED\">**具体代码如下：**</font>\n\n```c++\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#define lowbit(x) (x & (-x))\n#define ll long long\n#define pr(x) cout << #x << \" = \" << (x) << '\\n';\nusing namespace std;\n\nconst int MAXN = 210;//点数的最大值\nconst int MAXM = 20000;//边数的最大值\nconst int INF = 0x3f3f3f3f;\n\nstruct Edge\n{\n    int to,next,cap,flow;\n}edge[MAXM];//注意是MAXM\nint tol, src, des;\nint head[MAXN];\nint gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];\n\nvoid init()\n{\n    tol = 0;\n    memset(head,-1,sizeof(head));\n}\n//加边，单向图三个参数，双向图四个参数\nvoid addedge(int u,int v,int w,int rw=0)\n{\n    edge[tol].to = v;edge[tol].cap = w;edge[tol].next = head[u];\n    edge[tol].flow = 0;head[u] = tol++;\n    edge[tol].to = u;edge[tol].cap = rw;edge[tol].next = head[v];\n    edge[tol].flow = 0;head[v]=tol++;\n}\n//输入参数：起点、终点、点的总数\n//点的编号没有影响，只要输入点的总数\nint sap(int start,int end,int N)\n{\n    memset(gap,0,sizeof(gap));\n    memset(dep,0,sizeof(dep));\n    memcpy(cur,head,sizeof(head));\n    int u = start;\n    pre[u] = -1;\n    gap[0] = N;\n    int ans = 0;\n    while(dep[start] < N)\n    {\n        if(u == end)\n        {\n            int Min = INF;\n            for(int i = pre[u];i != -1; i = pre[edge[i^1].to])\n            if(Min > edge[i].cap - edge[i].flow)\n                Min = edge[i].cap - edge[i].flow;\n            for(int i = pre[u];i != -1; i = pre[edge[i^1].to])\n            {\n                edge[i].flow += Min;\n                edge[i^1].flow -= Min;\n            }\n            u = start;\n            ans += Min;\n            continue;\n        }\n        bool flag = false;\n        int v;\n        for(int i = cur[u]; i != -1;i = edge[i].next)\n        {\n            v = edge[i].to;\n            if(edge[i].cap - edge[i].flow && dep[v]+1 == dep[u])\n            {\n                flag = true;\n                cur[u] = pre[v] = i;\n                break;\n            }\n        }\n        if(flag)\n        {\n            u = v;\n            continue;\n        }\n        int Min = N;\n        for(int i = head[u]; i != -1;i = edge[i].next)\n            if(edge[i].cap - edge[i].flow && dep[edge[i].to] < Min)\n            {\n                Min = dep[edge[i].to];\n                cur[u] = i;\n            }\n        gap[dep[u]]--;\n        if(!gap[dep[u]])return ans;\n        dep[u] = Min+1;\n        gap[dep[u]]++;\n        if(u != start) u = edge[pre[u]^1].to;\n    }\n    return ans;\n}\n\nint mp[MAXN][MAXN], dp[MAXN][MAXN];\n\nvoid floyd(int n) {\n    for (int k = 0; k < n; ++k) {\n        for (int i = 0; i < n; ++i) {\n            if (dp[i][k] == INF) continue;\n            for (int j = 0; j < n; ++j) {\n                if (dp[k][j] == INF) continue;\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n            }\n        }\n    }\n}\n\nint main()\n{\n    int n;\n    while (~scanf(\"%d\", &n)) {\n        init();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                scanf(\"%d\", &mp[i][j]);\n                if (i == j) mp[i][j] = 0;\n                dp[i][j] = mp[i][j];\n                if (mp[i][j] == -1) dp[i][j] = INF;\n            }\n        }\n        scanf(\"%d%d\", &src, &des);\n\n        floyd(n);\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (mp[i][j] == -1) continue;\n                if (dp[src][des] == dp[src][i] + mp[i][j] + dp[j][des]) {\n                    addedge(i, j, 1);\n                }\n            }\n        }\n\n        if (src == des) printf(\"inf\\n\");\n        else printf(\"%d\\n\", sap(src, des, n));\n    }\n    return 0;\n}\n\n```\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "ZJU 2760 How Many Shortest Path (最大流)",
        "date": "2016-04-15 05:40:00",
        "tags": [
          "最大流"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n<font color=\"#6495ED\">**题目链接：**</font>[ZJU 2760 How Many Shortest Path (最大流)](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2760)\n\n<font color=\"#6495ED\">**题意分析：**</font>\n\n求从指定点到指定点的没有重边的最短路个数。如果起点终点相同，则输出“inf”。",
      "fileName": "ZJU-2760-How-Many-Shortest-Path-最大流"
    },
    {
      "content": "\n<font color=\"#6495ED\">**题目链接：**</font>[UESTC 92 Journey (离线LCA)](http://acm.uestc.edu.cn/#/problem/show/92)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \n给出一棵树和一条边，问加上这条边后，对于每一个查询，能优化多少的距离？\n<!--more-->\n\n<font color=\"#6495ED\">**解题思路：**</font>  \n这题多了一条边，那么我们只需要在查询的时候，特别考虑这条边存在的情况对原条件的影响即可。具体就是：  \n设新边为xy，费用w，查询的点为u和v，令$dis(u,v)$为点u和点v的树上最短距离，那么考虑新边之后，多出了两个路径，**一：**$dis(u,x) + dis(y,v) + w$；**二：**$dis(u,y) + dis(x,v) + w$；然后根据题意来搞就行了:)\n\n<font color=\"#6495ED\">**个人感受：**</font>  \n哦~我的第一想法是做两次tarjan，但是这样第二次加了新边做会放弃某条边，GG。其实我觉得缩点也是可以的，哈哈，不过我自己都嫌他麻烦。\n\n<font color=\"#6495ED\">**具体代码如下：**</font>\n\n``` c++\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#define pr(x) cout << #x << \" = \" << (x) << '\\n';\nusing namespace std;\n\nconst int INF = 0x7f7f7f7f;\nconst int MAXN = 1e5 + 111;\n\nstruct Edge {\n    int next, to, w;\n}edge[MAXN * 2];\n\nstruct Query {\n    int next, to, ans;\n}query[MAXN * 10];\n\nint head[MAXN], qhead[MAXN], tol, qtol;\nint dep[MAXN], par[MAXN];\nbool vis[MAXN];\n\nint find(int x) {\n    return x == par[x] ? x : par[x] = find(par[x]);\n}\n\nvoid init() {\n    tol = qtol = 0;\n    memset(head, -1, sizeof head);\n    memset(qhead, -1, sizeof qhead);\n    memset(vis, 0, sizeof vis);\n}\n\nvoid addedge(int u, int v, int w) {\n    edge[tol].to = v;\n    edge[tol].next = head[u];\n    edge[tol].w = w;\n    head[u] = tol++;\n}\n\nvoid qaddedge(int u, int v) {\n    query[qtol].to = v;\n    query[qtol].next = qhead[u];\n    qhead[u] = qtol++;\n    query[qtol].to = u;\n    query[qtol].next = qhead[v];\n    qhead[v] = qtol++;\n}\n\nvoid tarjan(int u, int sum) {\n    dep[u] = sum;\n    par[u] = u;\n    vis[u] = 1;\n    for (int i = head[u]; ~i; i = edge[i].next) {\n        int v = edge[i].to;\n        if (!vis[v]) {\n            tarjan(v, sum + edge[i].w);\n            par[v] = u;\n        }\n    }\n\n    for (int i = qhead[u]; ~i; i = query[i].next) {\n        int v = query[i].to;\n        if (vis[v]) {\n            query[i^1].ans = query[i].ans = dep[u] + dep[v] - 2 * dep[par[find(v)]];\n        }\n    }\n}\n\nint main()\n{\n    int t; scanf(\"%d\", &t);\n    int kase = 0;\n    while (t --) {\n        init();\n        int n, m;\n        scanf(\"%d%d\", &n, &m);\n        int u, v, w;\n        int u1, v1, w1;\n        for (int i = 0; i < n - 1; ++i) {\n            scanf(\"%d%d%d\", &u, &v, &w);\n            addedge(u, v, w);\n            addedge(v, u, w);\n        }\n        scanf(\"%d%d%d\", &u1, &v1, &w1);\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d%d\", &u, &v);\n            qaddedge(u, v);\n            qaddedge(u, u1);\n            qaddedge(v, v1);\n            qaddedge(u, v1);\n            qaddedge(v, u1);\n        }\n\n        tarjan(1, 0);\n\n        printf(\"Case #%d:\\n\", ++kase);\n        for (int i = 0; i < qtol; i += 10) {\n            int disuv = query[i].ans;\n            int disuu1 = query[i + 2].ans;\n            int disvv1 = query[i + 4].ans;\n            int disuv1 = query[i + 6].ans;\n            int disvu1 = query[i + 8].ans;\n            int mi = min(disuu1 + disvv1 + w1, disuv1 + w1 + disvu1);\n            printf(\"%d\\n\", disuv - min(disuv, mi));\n        }\n    }\n    return 0;\n}\n```\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "UESTC 92 Journey (离线LCA)",
        "date": "2016-04-14 22:08:59",
        "tags": [
          "LCA"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n<font color=\"#6495ED\">**题目链接：**</font>[UESTC 92 Journey (离线LCA)](http://acm.uestc.edu.cn/#/problem/show/92)\n\n<font color=\"#6495ED\">**题意分析：**</font>  \n给出一棵树和一条边，问加上这条边后，对于每一个查询，能优化多少的距离？",
      "fileName": "UESTC-92-Journey-离线LCA"
    },
    {
      "content": "\n## 写在前面\n\n>昨晚折腾到了凌晨4点，总算是收尾了，祝贺下~这篇也不打算讲具体如何建站，这类教程网上都是。所以打算总结下这期间比较让我费时的事情。\n\n<!--more-->\n\n## 推荐一个hexo主题：NexT  \n1.NexT很简洁，本站就是采用了NexT提供的三种主题中的NexT.Pisces  \n2.官方教程十分详细，基本按着教程来，80%的问题都是能解决的。附地址：[点我](http://theme-next.iissnan.com/getting-started.html)  \n3.当然，一切的前提是你已经部署好了博客XD\n\n## 关于Favicon\n官方说把ico图标命名为**favicon.ico**放到站点配置的**source**目录下即可，但是我的并不行，需要把图标放在**themes/next/source**下才可行\n\n## 推荐布置博客方法\n\n- 在github上的仓库中建立两个分支，其中master分支存放hexo生成的站点，另一个分支用于存放站点部署文件，也就是本地的那个文件。这样就不用担心换了电脑还得随身带着本地部署这种事情了。\n\n- 具体参考此人博客：[点我](http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more)\n\n- 有几点需要注意：  \n  1.记得把分支设为默认分支，具体在仓库页面的**setting**中设置,否则会使得push到本地仓库的是**master**。  \n  2.上传到git的部署文件不会将主题文件同步上去，因为主题本身是个仓库，网上说只需把主题里面的**.git**删除即可。~~然而对我没什么用，所以目前我是打算将来更新直接自己手动备份主题......~~  \n\n**Update**: 删除github上分支里的themes文件夹，然后删除本地next里面的.git文件，重新上传到github就能同步备份了。\n\n## 如何为文章分配到子分类\n具体的说法就是，比如某篇文章属于**“生活”**分类下的**“日志”**分类。那么只需在文章头添加\n```\ncategories: [生活,日志]\n```\n\n最终会生成分类信息：\n\n```\n- 生活(1)\n  - 日志(1)\n```\n\n顺便一提：多个书签也是同样的方法并排书写即可。\n\n## 最后呢，推荐一款windows下的本地markdown编辑器\n地址来啦：[免费哦，开源哦~](https://github.com/chenguanzhou/MarkDownEditor/releases)\n\n\n\n\n\n\n\n\n\n\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "建站小记",
        "date": "2016-04-13 19:48:36",
        "tags": [
          "杂谈"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n## 写在前面\n\n>昨晚折腾到了凌晨4点，总算是收尾了，祝贺下~这篇也不打算讲具体如何建站，这类教程网上都是。所以打算总结下这期间比较让我费时的事情。",
      "fileName": "建站小记"
    },
    {
      "content": "<font color=\"#6495ED\">**题目链接：**</font>[POJ 1986 Distance Queries (LCA)](http://poj.org/problem?id=1986)  \n<font color=\"#6495ED\">**题意分析：**</font>  \n求树上两点间的最短距离。  \n<!--more-->\n<font color=\"#6495ED\">**解题思路：**</font>  \n典型的离线LCA啊，主要是涉及到上一题的条件输入。不过本题边的朝向并不影响解题:)  \n<font color=\"#6495ED\">**个人感受：**</font>  \n时间主要废在看这题和上题题目上了2333  \n<font color=\"#6495ED\">**具体代码如下：**</font>\n```c++\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#define ll long long\n#define pr(x) cout << #x << \" = \" << (x) << '\\n';\nusing namespace std;\n\nconst int INF = 0x7f7f7f7f;\nconst int MAXN = 4e4 + 111;\nconst int MAXM = 8e4 + 222;\n\nstruct Edge {\n    int to, w, next;\n}edge[MAXM];\nint head[MAXN], tol;\n\nstruct Query {\n    int to, id, next;\n}query[MAXM];\nint qhead[MAXN], qtol, ans[MAXN], dis[MAXN];\n\nbool vis[MAXN];\n\nint par[MAXN];\n\nint find(int x) {\n    return par[x] == x ? x : par[x] = find(par[x]);\n}\n\nvoid init() {\n    tol = qtol = 0;\n    memset(head, -1, sizeof head);\n    memset(qhead, -1, sizeof qhead);\n}\n\nvoid addedge(int u, int v, int w) {\n    edge[tol].to = v;\n    edge[tol].w = w;\n    edge[tol].next = head[u];\n    head[u] = tol++;\n}\n\nvoid qaddedge(int u, int v, int id) {\n    query[qtol].to = v;\n    query[qtol].id = id;\n    query[qtol].next = qhead[u];\n    qhead[u] = qtol++;\n}\n\nvoid dfs(int u, int sum) {\n    dis[u] = sum;\n    vis[u] = 1;\n    for (int i = head[u]; ~i; i = edge[i].next) {\n        int v = edge[i].to;\n        if (!vis[v]) {\n            dfs(v, sum + edge[i].w);\n        }\n    }\n}\n\nvoid tarjan(int u) {\n    par[u] = u;\n    vis[u] = 1;\n    for (int i = head[u]; ~i; i = edge[i].next) {\n        int v = edge[i].to;\n        if (vis[v]) continue;\n        tarjan(v);\n        par[v] = u;\n    }\n    for (int i = qhead[u]; ~i; i = query[i].next) {\n        int v = query[i].to;\n        if (vis[v]) {\n            ans[query[i].id] = dis[u] + dis[v] - 2 * dis[find(par[v])];\n        }\n    }\n}\n\nint main()\n{\n    #ifdef LOCAL\n    freopen(\"C:\\\\Users\\\\apple\\\\Desktop\\\\in.txt\", \"r\", stdin);\n    #endif\n    int n, m;\n    while (~scanf(\"%d%d\", &n, &m)) {\n        int u, v, w, k;\n        init();\n        char s[2];\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d%d%d%s\", &u, &v, &w, s);\n            addedge(u, v, w);\n            addedge(v, u, w);\n        }\n        scanf(\"%d\", &k);\n        for (int i = 0; i < k; ++i) {\n            scanf(\"%d%d\", &u, &v);\n            qaddedge(u, v, i);\n            qaddedge(v, u, i);\n        }\n\n        memset(vis, 0, sizeof vis);\n        dfs(1, 0);\n        memset(vis, 0, sizeof vis);\n        tarjan(1);\n\n        for (int i = 0; i < k; ++i) {\n            printf(\"%d\\n\", ans[i]);\n        }\n    }\n    return 0;\n}\n```\n\n\n---\n\n**广告时间**\n\n\n\n\n> *Java学习网站*: <a href=\"http://how2j.cn?p=23251\" target=\"_blank\">![how2j](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/how2j.png?raw=true)</a>\n\n> *VPS*: <a href=\"https://www.vultr.com/?ref=7255071\" target=\"_blank\">![VPS](https://github.com/GooZy/GooZy.github.io/blob/hexo/source/images/banner_2.png?raw=true)</a>\n\n",
      "data": {
        "title": "POJ 1986 Distance Queries (LCA)",
        "date": "2016-04-13 03:07:49",
        "tags": [
          "LCA"
        ],
        "published": true,
        "hideInList": false,
        "feature": null
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "<font color=\"#6495ED\">**题目链接：**</font>[POJ 1986 Distance Queries (LCA)](http://poj.org/problem?id=1986)  \n<font color=\"#6495ED\">**题意分析：**</font>  \n求树上两点间的最短距离。  ",
      "fileName": "POJ-1986-Distance-Queries-LCA"
    }
  ],
  "tags": [
    {
      "name": "总结",
      "slug": "zong-jie",
      "used": true
    },
    {
      "name": "旅行",
      "slug": "lu-xing",
      "used": true
    },
    {
      "name": "图像",
      "slug": "tu-xiang",
      "used": true
    },
    {
      "name": "日本",
      "slug": "ri-ben",
      "used": true
    },
    {
      "name": "生命游戏",
      "slug": "sheng-ming-you-xi",
      "used": true
    },
    {
      "name": "无边界地图",
      "slug": "wu-bian-jie-di-tu",
      "used": true
    },
    {
      "name": "爬虫",
      "slug": "pa-chong",
      "used": true
    },
    {
      "name": "HyperComments",
      "slug": "hypercomments",
      "used": true
    },
    {
      "name": "Java",
      "slug": "java",
      "used": true
    },
    {
      "name": "泛型",
      "slug": "fan-xing",
      "used": true
    },
    {
      "name": "git",
      "slug": "git",
      "used": true
    },
    {
      "name": "笔记",
      "slug": "bi-ji",
      "used": true
    },
    {
      "name": "开源",
      "slug": "kai-yuan",
      "used": true
    },
    {
      "name": "链表",
      "slug": "lian-biao",
      "used": true
    },
    {
      "name": "实现",
      "slug": "shi-xian",
      "used": true
    },
    {
      "name": "数据结构",
      "slug": "shu-ju-jie-gou",
      "used": true
    },
    {
      "name": "二进制",
      "slug": "er-jin-zhi",
      "used": true
    },
    {
      "name": "数学",
      "slug": "shu-xue",
      "used": true
    },
    {
      "name": "算法",
      "slug": "suan-fa",
      "used": true
    },
    {
      "name": "图论",
      "slug": "tu-lun",
      "used": true
    },
    {
      "name": "动态规划",
      "slug": "dong-tai-gui-hua",
      "used": true
    },
    {
      "name": "tarjan",
      "slug": "tarjan",
      "used": true
    },
    {
      "name": "2-SAT",
      "slug": "2-sat",
      "used": true
    },
    {
      "name": "树链剖分",
      "slug": "shu-lian-pou-fen",
      "used": true
    },
    {
      "name": "线段树",
      "slug": "xian-duan-shu",
      "used": true
    },
    {
      "name": "DFS",
      "slug": "dfs",
      "used": true
    },
    {
      "name": "LCA",
      "slug": "lca",
      "used": true
    },
    {
      "name": "RMQ",
      "slug": "rmq",
      "used": true
    },
    {
      "name": "BIT",
      "slug": "bit",
      "used": true
    },
    {
      "name": "BFS",
      "slug": "bfs",
      "used": true
    },
    {
      "name": "ST",
      "slug": "st",
      "used": true
    },
    {
      "name": "最大流",
      "slug": "zui-da-liu",
      "used": true
    },
    {
      "name": "杂谈",
      "slug": "za-tan",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "gridea",
      "used": false
    },
    {
      "index": -1,
      "name": "书",
      "slug": "84dzn3Eut",
      "used": false
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    },
    {
      "link": "/post/books",
      "name": "书单",
      "openType": "Internal"
    },
    {
      "link": "/post/bbs",
      "name": "留言板",
      "openType": "Internal"
    }
  ]
}