{"posts":[{"title":"SLF4J源码分析（二）——SLF4J 绑定实现原理","content":"总的入口就是这句 LoggerFactory.getLogger(Main.class)，我们从这里入手。 public class Main { private static final Logger LOGGER = LoggerFactory.getLogger(Main.class); public static void main(String[] args) { LOGGER.info(&quot;\\\\{} {} test&quot;, &quot;hello&quot;); LOGGER.info(&quot;\\\\\\\\{}&quot;, &quot;place&quot;); } } 1.8.0 之前 在 SLF4J 1.8.0 版本之前，它依赖于 Java 类加载机制，通过特定的类名来查找并加载具体框架的绑定实现。我们看下具体的实现： getLogger 会使用传入的类名进行查找，它首先需要找到具体的 ILoggerFactory 实例，然后调用 getLogger(name) 方法获取指定名称的 Logger 实例。ILoggerFactory 的实现类会根据具体的日志框架实现来创建和返回 Logger 实例。 public static Logger getLogger(String name) { ILoggerFactory iLoggerFactory = getILoggerFactory(); return iLoggerFactory.getLogger(name); } 顺着 getILoggerFactory() 往下追，能够找到 bind() 方法，它是整个加载的核心。 private final static void bind() { try { Set&lt;URL&gt; staticLoggerBinderPathSet = null; // skip check under android, see also // http://jira.qos.ch/browse/SLF4J-328 if (!isAndroid()) { // 查找可能的 `StaticLoggerBinder` 的路径集合 staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet(); reportMultipleBindingAmbiguity(staticLoggerBinderPathSet); } // the next line does the binding StaticLoggerBinder.getSingleton(); INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION; reportActualBinding(staticLoggerBinderPathSet); fixSubstituteLoggers(); replayEvents(); // release all resources in SUBST_FACTORY SUBST_FACTORY.clear(); } catch (NoClassDefFoundError ncde) { String msg = ncde.getMessage(); if (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) { INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION; Util.report(&quot;Failed to load class \\&quot;org.slf4j.impl.StaticLoggerBinder\\&quot;.&quot;); Util.report(&quot;Defaulting to no-operation (NOP) logger implementation&quot;); Util.report(&quot;See &quot; + NO_STATICLOGGERBINDER_URL + &quot; for further details.&quot;); } else { failedBinding(ncde); throw ncde; } } catch (java.lang.NoSuchMethodError nsme) { String msg = nsme.getMessage(); if (msg != null &amp;&amp; msg.contains(&quot;org.slf4j.impl.StaticLoggerBinder.getSingleton()&quot;)) { INITIALIZATION_STATE = FAILED_INITIALIZATION; Util.report(&quot;slf4j-api 1.6.x (or later) is incompatible with this binding.&quot;); Util.report(&quot;Your binding is version 1.5.5 or earlier.&quot;); Util.report(&quot;Upgrade your binding to version 1.6.x.&quot;); } throw nsme; } catch (Exception e) { failedBinding(e); throw new IllegalStateException(&quot;Unexpected initialization failure&quot;, e); } } 在 bind() 方法中，findPossibleStaticLoggerBinderPathSet() 查找可能的 StaticLoggerBinder 的路径集合。主要逻辑就是通过类加载器，获取所有 org/slf4j/impl/StaticLoggerBinder.class 的资源。可以看到，所有支持 SLF4J 的框架，都在指定路径定义了这个类。 StaticLoggerBinder.getSingleton(); 这里会进行实际的绑定。在有多个实现的情况下，会依据类加载顺序，选择第一个。如果 SLF4J 在类路径中找不到任何 SLF4J 绑定，那么它将默认使用 NOP（No Operation）绑定，就是说没有任何日志输出。也就是下面的 NOP_FALLBACK_FACTORY。 public static ILoggerFactory getILoggerFactory() { ... switch (INITIALIZATION_STATE) { case SUCCESSFUL_INITIALIZATION: return StaticLoggerBinder.getSingleton().getLoggerFactory(); case NOP_FALLBACK_INITIALIZATION: return NOP_FALLBACK_FACTORY; ... } throw new IllegalStateException(&quot;Unreachable code&quot;); } 1.8.0 及之后 从 SLF4J 1.8.0 版本开始，SLF4J 使用了 ServiceLoader 机制来加载日志框架的实现。当应用程序启动时，ServiceLoader 会扫描所有的类路径，查找并加载可用的日志框架实现。 依旧是最关键的 bind()： private final static void bind() { try { List&lt;SLF4JServiceProvider&gt; providersList = findServiceProviders(); reportMultipleBindingAmbiguity(providersList); ... } catch (Exception e) { failedBinding(e); throw new IllegalStateException(&quot;Unexpected initialization failure&quot;, e); } } 在findServiceProviders()，提供了两种方式对服务提供者进行加载。 通过系统变量 slf4j.provider 来指定。 通过 ServiceLoader.load() 加载 SLF4JServiceProvider.class 对象列表。这里使用了 Java 的 SPI 机制，该机制会扫描 META-INF/services 下的文件，文件名为接口全限定名，内容是实现了这个接口的类的全限定名。关于 SPI，大家可以看看这篇文章剖析 SPI 在 Spring 中的应用。 为什么有这样的改变？ 在 SLF4J 1.8.0 版本之前，对于其他日志框架，需要在自己项目实现一个包名为 org.slf4j.impl 的类，这会导致代码与 SLF4J 框架耦合。 对于 SLF4J 自身，它自身不能有类 StaticLoggerBinder，但是为了编译通过，还是需要提供一个简单的实现，然后在打包阶段删除。 SLF4J 2004就开始发布，而 Java SPI 直到 2006 年才正式加入标准库。 ","link":"https://goozy.github.io/post/slf4j-source-code-analyze-2-binding-imp/"},{"title":"SLF4J源码分析（一）","content":"介绍 SLF4J（Simple Logging Facade for Java）是一个简单的日志门面框架，它允许应用程序使用单一的 API 进行日志记录，而不用关心具体的日志实现。SLF4J 提供了一个简单的抽象层，可以在运行时绑定到不同的日志框架，比如 logback、log4j 等。 下面是官方对于框架的一个介绍图，浅蓝色是抽象日志 API、蓝色是原生 slf4j-api 的实现，墨绿是适配层，因为有些框架比如 reload4j、log4j 等，并没有对原生 slf4j-api 的实现，所以官方提供了这样的适配层。应用只需要调用 slf4j 的 API，而不用关心日志框架的具体实现。 SLF4J-API 源码总览 - org.slf4j ---- event # 包含 SLF4J 的事件类，用于表示日志记录事件。 ---- helpers # 包含了一些实用工具类，用于帮助开发人员更方便地使用 SLF4J 记录日志。 ---- spi # 下游需要提供的接口 ---- ... event 包 提供了一个基本的日志事件实现 SubstituteLoggingEvent，以及 EventRecodingLogger，用于在具体日志框架初始化期间，框架内部有日志记录时，作为临时的日志记录。issue 参见 static SLF4JServiceProvider getProvider() { if (INITIALIZATION_STATE == UNINITIALIZED) { synchronized (LoggerFactory.class) { if (INITIALIZATION_STATE == UNINITIALIZED) { INITIALIZATION_STATE = ONGOING_INITIALIZATION; // 这里将状态置为ONGOING_INITIALIZATION performInitialization(); } } } switch (INITIALIZATION_STATE) { case SUCCESSFUL_INITIALIZATION: return PROVIDER; case NOP_FALLBACK_INITIALIZATION: return NOP_FALLBACK_SERVICE_PROVIDER; case FAILED_INITIALIZATION: throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG); // 如果在初始化期间有其它调用进来，使用SUBST_PROVIDER，也就是SubstituteServiceProvider，底层是使用EventRecodingLogger case ONGOING_INITIALIZATION: // support re-entrant behavior. // See also http://jira.qos.ch/browse/SLF4J-97 return SUBST_PROVIDER; } throw new IllegalStateException(&quot;Unreachable code&quot;); } 在初始完成后，会将这部分记录的日志，重新用找到的具体实现进行重放。 private static void postBindCleanUp() { fixSubstituteLoggers(); // 设置具体logger replayEvents(); // 使用具体logger重放期间记录的日志 // release all resources in SUBST_FACTORY SUBST_PROVIDER.getSubstituteLoggerFactory().clear(); } helpers 包 BasicMarker 对marker的基本实现，主要就是打印关联的 marker 名字作为日志上下文的补充。在 logback 中可以用 %marker 进行获取，也能通过 marker 对日志进行过滤。 public String toString() { if (!this.hasReferences()) { return this.getName(); } Iterator&lt;Marker&gt; it = this.iterator(); Marker reference; StringBuilder sb = new StringBuilder(this.getName()); sb.append(' ').append(OPEN); while (it.hasNext()) { reference = it.next(); sb.append(reference.getName()); if (it.hasNext()) { sb.append(SEP); } } sb.append(CLOSE); return sb.toString(); } MessageFormatter 日志的格式化类 final public static FormattingTuple arrayFormat(final String messagePattern, final Object[] argArray) { // 获取传参列表中的最后一个参数，判断是否是异常对象 Throwable throwableCandidate = MessageFormatter.getThrowableCandidate(argArray); Object[] args = argArray; if (throwableCandidate != null) { args = MessageFormatter.trimmedCopy(argArray); } // 根据占位符构造日志内容。 // 比较有意思的是，替换是从左往右开始，循环次数由参数列表长度决定。 // 这种性质使得，在参数列表个数个占位符后的内容，都不需要额外处理。 return arrayFormat(messagePattern, args, throwableCandidate); } final public static FormattingTuple arrayFormat(final String messagePattern, final Object[] argArray, Throwable throwable) { ...... int i = 0; int j; // use string builder for better multicore performance StringBuilder sbuf = new StringBuilder(messagePattern.length() + 50); int L; // 根据参数列表长度，进行查询 for (L = 0; L &lt; argArray.length; L++) { j = messagePattern.indexOf(DELIM_STR, i); // 查找字符串&quot;{}&quot; if (j == -1) { // no more variables if (i == 0) { // this is a simple string return new FormattingTuple(messagePattern, argArray, throwable); } else { // add the tail string which contains no variables and return // the result. sbuf.append(messagePattern, i, messagePattern.length()); return new FormattingTuple(sbuf.toString(), argArray, throwable); } } else { // 前一个字符是否是转义字符'\\' if (isEscapedDelimeter(messagePattern, j)) { // 是单个转义字符'\\'，那么就删除转义字符，添加字符串&quot;{}&quot;到内容中 // log.info(&quot;\\\\{} {} test&quot;, &quot;hello&quot;) -&gt; &quot;{} hello test&quot; if (!isDoubleEscaped(messagePattern, j)) { L--; // DELIM_START was escaped, thus should not be incremented sbuf.append(messagePattern, i, j - 1); sbuf.append(DELIM_START); i = j + 1; } else { // The escape character preceding the delimiter start is // itself escaped: &quot;abc x:\\\\{}&quot; // we have to consume one backward slash // log.info(&quot;\\\\\\\\{}&quot;, &quot;place&quot;) -&gt; &quot;\\place&quot; sbuf.append(messagePattern, i, j - 1); deeplyAppendParameter(sbuf, argArray[L], new HashMap&lt;Object[], Object&gt;()); i = j + 2; } } else { // normal case sbuf.append(messagePattern, i, j); deeplyAppendParameter(sbuf, argArray[L], new HashMap&lt;Object[], Object&gt;()); i = j + 2; } } } // append the characters following the last {} pair. sbuf.append(messagePattern, i, messagePattern.length()); return new FormattingTuple(sbuf.toString(), argArray, throwable); } ","link":"https://goozy.github.io/post/slf4j-source-code-analyze-1/"},{"title":"【翻译】PDF中的数字签名[3]","content":"原文：Digital Signatures in a PDF 三、PDF语言签名功能 1. 标准支持 PDF本身是一个开放的ISO标准。ISO 32000对PDF中的数字签名支持进行了全面描述，Adobe在其开放SDK中提供了与PDF和Acrobat系列产品api交互的工具。但是，PDF中也内置了对其他标准的支持，像Acrobat和Adobe Reader这样的PDF阅读器应该遵守表2（注：见原文第五部分）中列出的标准。 2. 支持替换签名方法 大多数签名都是纯数学的，例如由Arcobat的默认签名处理程序生成的公私钥加密文件摘要。然而，它们也可以是生物识别的形式，例如手写签名、指纹或视网膜扫描。签名处理程序根据PDF ISO标准中定义的规则处理数据并控制身份验证的形式。 3. 支持两种签名类型 PDF定义了两种类型的签名：批准和认证。这两种类型都是覆盖所有文件内容的字节范围签名。两者都可以在文件签署时对文件进行可视化快照，从而提供高级别的文件完整性。 区别如下： 批准：一份文件中可以有任意数量的批准签名。该字段可以选择与FieldMDP权限相关联。参见“锁定表单域”部分。 认证：一份文件只能有一个认证签名且必须为第一个。该字段总是与DocMDP（参见“控制签署后变更”部分）和法律内容证明相关联。它们可以选择与FieldMDP权限相关联。 4. 签名互操作 PDF允许在签名处理程序和合格阅读器之间的互操作。也就是说，使用处理程序ABC签署的PDF应该能够使用来自不同供应商的处理程序XYZ进行验证。 当存在时，签名字典中的SubFilter条目指定签名值和密钥信息的编码，而Filter条目指定应用于验证签名的首选处理程序。SubFilter条目有几个定义的值，所有这些值都基于RSA Security发布的公钥加密标准，也是国际互联网工程任务组（IETF）公钥基础设施（PKIX）工作组发布的标准的一部分。 5. 鲁棒算法支持 随着安全问题的发展，PDF扩展了对日益强大的加密算法的支持，如下所示。 可以通过种子值或在应用程序首选项级别（例如注册表）来指定摘要算法。 6. 多重签名 有些文件可能需要多个签名。 只需要在纸上画另一条线就可以很容易地处理纸质文件。在纸张世界中，在文件上签署的人应该明智地在文件签署后保存副本。然后，如果另一个人更改了文件，签名者可以很容易地辩称文件已被更改。 但是，对于PDF，任何通过修改文件（如再次签署）来更改文档的尝试都将使现有的数字签名无效。这是因为验证时计算的哈希值与签署时创建的加密哈希值不匹配。 PDF通过支持增量更新的功能解决了这个问题（参见“增量更新”部分）。只要其他权限限制（如DocMDP和FieldMDP）不阻止其他签名，签名者就可以向文件中添加另一个签名字段并签名，而不会使先前的签名无效。 7. 增量更新 PDF文件格式定义了增量更新功能。增量更新对查看文件的人是透明的，但允许检测和审核对文件的修改。 通常，PDF语言（特别是针对已签署文件）允许任何PDF文件通过在文件末尾增加增量更新部分来进行修改。不需要对表示文件早期版本的字节进行任何更改。这样就可以往PDF文件添加签名而不会修改之前签名覆盖的任何数据。 每个附加签名将覆盖整个PDF文件，从第0个字节到最后一个字节，但不包括当前签名值的签名值。图5展示了如何为具有三个签名的文件创建签名。 8. 查看之前的签署文件版本 PDF语言的增量更新功能允许PDF阅读器有效保留任何PDF文件的所有签署版本。这使得用户能够实际看到已签署的PDF文件的版本。 Acrobat通过提供两种特性来充分利用PDF的能力达到签署时“记住”文档状态： 查看签署版本：通过右键单击签名并选择“查看签署版本”，显示应用签名时的文件。这个操作可以通过删除与签名对应的文件EOF之后任意字节来手动模拟。 比较签署版本与当前版本：通过右键单击签名并选择“比较签署版本与当前版本”，将文件的当前版本与签署版本进行比较。 9. 比较当前文件版本和签署文件版本 参见“查看之前的签署版本”部分 10. 锁定表单域 表单域包括签名域和非签名域，表单通常包含许多表单域，有些是为签名设计的，有些是为表单数据设计的。PDF语言允许作者控制文档签名后是否可以填写额外的字段，不论是通过签名，还是通过输入任何类型的数据。创建文档时，作者可以指定以下内容： 是否可以在不使批准或认证签名失效的情况下填写表单域。 在特定的接收者签署文件后，任何对特定表单域的修改都会使这个接收者的签名无效。在这种情况下，为每个接收者指定一个单独的签名域。 FieldMDP转换方法用于检测文档表单域值的更改。（见图1） 11. 控制签署后变更 PDF提供了一种限制后签名的机制。该机制是DocMDP转换方法（修改、检测和预防的缩写）。DocMDP转换参数字典中的P条目指示对文件的以下哪些更改将使签名无效（见图1）： 任何修改 表单填写和数字签名 注释（评论）、表单填写、数字签名 文件只能包含一个包含DocMDP转换方法的签名域，并且必须是文档中的第一个签名域。该签名称为“认证”签名。此功能允许作者指定哪些更改是允许的，哪些更改使作者的签名无效。然而，大多数用户会认为DocMDP的作用是指定他们可以对文档做什么。 认证签名应具有一个合法的证明字典，该字典指定可能导致文档内容非预期解读的所有内容，以及作者对此类内容的证明。如果文件的完整性受到质疑，本字典可用于确定作者的意图。 Acrobat允许第一个签名者使用认证签名来认证文档，并在签署过程中设置权限和法律证明。 打开已认证的文件时，除了打开已认证时存在的文件并将其与当前正在查看的内存中的文件（包括所有增量更改）进行比较外，签名会像往常一样被验证。进行修改分析，任何作者禁止的修改会被报告。违反权限会破坏签名。 12. 法律内容证明 鉴于其内在的丰富性，PDF语言提供了许多可能导致PDF文档呈现外观变化的功能（例如多媒体或JavaScript）。这些功能会有意或无意地构造误导文件收件人的文件。在考虑签署的PDF文件的法律含义时，这些情况是相关的。 为了促进文件信任，合格的认证签名作者（例如Acrobat）也应利用PDF的法律证明字典。字典条目指定所有可能导致文档内容意外呈现的内容。此外，作者可以通过证明条目（Attestation entry）进一步澄清此类内容。审稿人应自己确定他们信任作者和文档内容。 13. 基于文件权限启用功能 PDF使具有丰富PDF交互的功能齐全的客户端能够向功能较差的客户端授予文档特定的权限，以便它们也可以使用其中的一些功能。使用此机制，可以向不具有数字签名功能的客户机授予该功能。当在特定文件的语言级别授予权限时，任何与签名相关的用户界面元素都将启用。 例如，使用Acrobat的作者可以使用公钥加密技术授予在Adobe Reader中启用其他功能的权限。它使用证书颁发机构向与其建立业务关系的文件创建者颁发公钥证书。Adobe Reader验证授权签名是否使用Adobe授权证书颁发机构的证书。因此，打开阅读器支持文档的Adobe Reader用户可以签名、填写表单字段，反之执行被禁止的操作。 这种机制称为使用权签名，通常对终端用户是透明的。使用权限签名是从权限字典中的UR3条目引用的（图1）。签名启用了其他交互式功能，这些功能在符合条件的阅读器中可能默认情况下不可用，并验证权限是否已由真正的授权机构授予。转换参数字典指定了在签名有效时应启用的附加权限。如果签名由于任何原因无效，则不会授予其他权利。 14. 富证书处理 PDF支持富证书加工和处理功能，因为它的证书数据是嵌入到签名中的。PDF阅读器和签名处理程序可以根据需要使用这些数据。例如，当使用PKCS#7签名，签名对象可以包含以下部分或者全部： 时间戳信息 嵌入的吊销信息 CRLs和OCSP的吊销检查详情 证书策略和属性证书 15. 通过种子值控制签名工作流 PDF对种子值的支持在文档被路由到签署方后，为作者提供了对文件行为的字段级控制。种子值指定属性和属性值，作者可以控制指定的参数是可选的还是任何特定字段必须包含的。 例如，您可以使用种子值来限制用户在签署特定的签名字段时的选择，例如要求使用特定CA颁发的证书进行签名。当签名者签署一个“种子”字段时，作者指定的行为将被自动调用且是强制的。 如果字段字典包含引用种子值字典的SV条目，那么当字段被签名时将使用该字典。Ff条目指定字典中的其他条目是否应该被考虑，或者是否仅仅是推荐。Acrobat的默认处理程序支持PDF标准定义的所有种子值。Acrobat为种子值字段提供了api。 ","link":"https://goozy.github.io/post/digital-signatures-in-a-pdf-chinese-version-3/"},{"title":"【翻译】PDF中的数字签名[2]","content":"原文：Digital Signatures in a PDF 二、公钥基础设施（PKI） PDF的数字签名功能旨在与企业和政府环境中部署的与主流公钥基础设施（PKI）相关的所有标准兼容。PKI是在创建，分发，管理，吊销以及使用数字ID时使用的人员，策略，过程，硬件和软件的集合，这些数字ID中包含签署PDF时使用的公钥/私钥对。 在PDF签名工作流的上下文中，“PKI”通常指数字ID的颁发者、用户、管理员以及任何在这些工作流中使用的软硬件。实现并符合PDF语言标准的PDF阅读器能够以无缝且健壮的方式与这些组件交互。 在签署重要的纸质文件时，人们通常需要向公证人或其他受信任的机构提供令人满意的身份证明，之后在他们面前对文件进行签署。 因为公证人被认为是值得信赖的，所以你可以信任公证人见证的签名。 使用PKI是一种提供类似信任的方法。 与提供信任直接相关的一些常见PKI组件包括： 证书颁发机构（CA）：最终的信任机构，可以出售或发行数字ID（例如Verisign或Geotrust）。 CA会签署自己的证书（自我签名），并且其证书通常是证书链顶部的“根”证书。 中间证书（ICAs）：一种CA，在证书链中其位于终端用户和根证书之间。 该证书不是自签名的，并且ICA通常提供诸如策略，时间戳，吊销列表等服务。 终端用户证书（EE）：签署者的证书，也是签署链上最后的元素。根据定义，终端用户证书不包含CA基本约束值。 数字ID：与个人或实体相关联的基于ITU-T X.509 v3标准的数据电子表示形式。 它存储在计算机或网络上受密码保护的文件，USB令牌，智能卡等中。数字ID包含公钥证书，私钥和其他数据 公钥证书：一个包含公钥/私钥对的数字公钥部分以及用于定义证书所有者，有效期和用法的关联扩展和属性的文件。 私钥：PKI系统中的密钥，用于验证传入消息和对传出消息进行签名。在密钥生成期间，私钥始终与其公钥配对。 尽管数字ID及其发行实体是任何PKI的核心，但PKI还包括许多其他企业所有和第三方项目。 PKI管理员通常管理着数字ID的创建与分发，LDAP（Light Directory Access Portocol）服务器，时间戳服务器，吊销列表和其他项目。PDF语言支持所有与这些组件交互所需的数据。 1. PKI，PDF和签署 PDF支持将签名嵌入文件自身，而不是作为单独的数据管理或者添加到现有文件格式中。这意味着查看应用程序可以不破坏签名而进行特定类型的修改。对于其它数字签名格式，用户可能需要使用两个应用来处理文件和签名，或者需要为每个签名文件管理两份单独的文件。 PDF中的每个签名都与签名处理程序关联。签名被放置在PDF签名字典中，里面包含用于处理签名的签名处理器名字（如图3）。Adobe Acrobat leverages Public/Private Key（PPK）加密技术内置了签名处理程序。PPK基于这样一种思想，即用私钥加密的值只能使用公钥解密（反之，在为特定收件人加密文件时也是同样的，但这不在本文档的范围之内）。 对PDF进行签名后，签名者的证书将嵌入在PDF文件中。图3展示了存储在用户硬件设备上的数字ID与嵌入PDF文件中签名值的关系。签名值可能还包含额外的信息，例如签名图片，时间戳和可能特定于用户，系统或应用程序的其他数据。 签署过程如下： 待签名文件被处理成字节流。 将整个PDF文件写入磁盘，并留出适当大小的空间用于签名值以及ByteRange数组中的最坏情况值。 ByteRange数组由四个数字组成。每对中的第一个数字是对于文件的偏移量（从头开始，起始是0），表示需要被包含在哈希计算中的字节流的起始。第二个数字是该流的长度。这两对定义了两个字节序列，这些字节序列定义了要哈希的内容。实际签名值存储在第一个序列的末尾与第二个序列的开头之间的/Contents键中。图4中，哈希是针对字节0到839和960到1200计算的。 一旦根据文件中的偏移量知道了签名值的位置，就可以使用正确的值填充ByteRange数组。因为字节偏移禁止修改，所以新数组语句之后的多余字节将被零覆盖。 使用诸如SHA-256之类的哈希算法，由实际ByteRange值指定的字节来计算整个文件的哈希。Acrobat始终在整个PDF文件中计算文件签名的哈希值，该哈希值从字节0开始到物理文件的最后一个字节结束，但不包括签名值字节。 哈希值由签署者的私钥加密，并生成一个十六进制编码的PKCS#7对象签名对象。 签名对象放置在磁盘上的文件中，覆盖占位符/Contents值。 未用于签名对象的任何空间都将被零覆盖。 将PDF文件重新加载到Acrobat中，以确保内存和磁盘上的版本相同。 提示： 这是一个高层级展示。对于更详细的一些应用程序级配置选项的快速键，请参阅“签名创建工作流”。 2. PKI，PDF和签名校验 由于私钥和公钥仅仅是数字，因此任何人都可以使用任意数量的工具生成公钥和私钥对。 诸如Acrobat之类的应用程序提供了一种生成自签名证书的机制，该证书将简单的用户提供的身份绑定到由应用程序生成的公钥。 然后使用相应的私钥对其进行签名。 显然，没有什么可以阻止某人生成使用他人名字的自签名证书的。 因此，未知的自签名证书没有很高的保证水平。 为了解决这种类型的信任问题，组织者使用一种PKI，该PKI包括发布，记录和跟踪数字ID的独立权限。 由于PDF支持将签名者的公共密钥作为签名的一部分进行嵌入，因此文件接收者始终可以使用它来进行签名验证。要验证签名，验证者只需检索签名者的证书，并将其与自己的受信任证书列表进行比较： 收件人的应用程序使用签名者使用的相同算法（不包括签名值）来生成文件的单向哈希。 使用签名者的公钥对文件中加密的哈希值进行解密。 将解密的哈希值与本地生成的哈希值进行比较。 如果它们相同，则将签名报告为已知。 提示： 签名是否受信任或有效是单独的问题。 签名信任取决于收件人的应用程序配置。 签名状态还取决于文件完整性检查。 ","link":"https://goozy.github.io/post/digital-signatures-in-a-pdf-chinese-version-2/"},{"title":"【翻译】PDF中的数字签名[1]","content":"原文：Digital Signatures in a PDF 一、在PDF文件中表示签名 在PDF中，签名信息包含在一个签名字典中。字典中的对象由PDF Reference定义。签名字典可以引用或者被其它字典引用，通常是下图这样。这些字典中的条目决定了签名的性质和特征，并通过扩展确定了哪些数据可被任何设计用于签名数据处理的PDF阅读器使用。 尽管其他阅读器对PDF语言功能的支持可能有所不同，但Acrobat系列产品支持所有这些功能。从较高的层次上讲，这些功能可以分为以下几类： 为文件添加数字签名。 校验签名有效性。 控制签名工作流的权限和限制。 当然，PDF包含一些与这些活动相关但非必须的功能。例如，支持添加签署原因对于签署来说不是很相关，但是对于许多工作流来说是有价值的。 提示：对于完整的PDF语言细节，请参考PDF Reference。 ","link":"https://goozy.github.io/post/digital-signatures-in-a-pdf-chinese-version-1/"},{"title":"【翻译】PDF中的数字签名[0]","content":"原文：Digital Signatures in a PDF 本文档介绍了如何在PDF文件中表示数字签名，以及PDF语言支持哪些与签名相关的功能。Adobe® Reader®与Acrobat®实现了PDF的所有功能，因此为基于公钥基础设施（PKI）技术的数字数据认证提供了全面的支持。第三方开发人员可以以Acrobat插件签名处理程序的形式定义自己的处理方式。 数字签名可以用于过去使用传统笔墨签名的许多类型的文件中。然而，仅仅存在一个数字签名并不能充分保证一个文件就是它看起来的样子。此外，政府和企业通常有需要对其签名工作流施加附加约束的设置，例如在签名期间和之后限制用户的选择和文件行为。 无论使用何种PDF查看程序，PDF语言都支持下列内容： 标准支持 支持替换签名方法 支持两种签名类型 签名互操作 鲁棒算法支持 多重签名 增量更新 查看之前的签署文件版本 比较当前文件版本和签署文件版本 锁定表单域 控制签署后变更 法律内容证明 基于文件权限启用功能 富证书处理 通过种子值控制签名工作流 ","link":"https://goozy.github.io/post/digital-signatures-in-a-pdf-chinese-version-0/"},{"title":"我开发的第一款chrome插件——“标签文件夹”介绍","content":"“标签文件夹”是一款用来临时保存浏览器标签页的插件。是我个人开发的第一款Chrome插件，希望能够帮到和我一样，标签页偶尔会塞满浏览器的人。 适用场景 看到一些感兴趣的页面（视频/文章），目前没时间看，就可以用“标签文件夹”将它们收录。 这些项目我都感兴趣，先开个标签，慢慢一个一个看，总会看完的╮(￣▽￣)╭ 像上图这样，标签开多了，一时半会看不完，就容易影响到正在使用的标签页。另外观感上也让人难受。把他们放到收藏夹吧，又嫌麻烦，之后打开看还得删除收藏夹链接。 用了我们“标签文件夹”后，以上都不是问题。(～￣▽￣)～ 使用指南 初始 这是初始界面，文件夹容量可以通过左上角的设置按钮，进入设置页面更改。目前设定最大可以调节到50个。应该没有人需要保存这么多标签页吧。。。 添加 目前有三种方式可以添加到“标签文件夹”。 使用 Ctrl(Win)/Command(Mac)+K 使用弹出页面上的添加按钮 使用鼠标右键点击页面或者链接，可以快捷选择保存 添加后效果如图 点击链接，就会自动打开标签页到当前窗口，然后相应的链接会自动删除。 图标上还有一个“当前标签页数量”的蓝色数字，时时刻刻提醒你，“你还藏着这么多私货没看呢（笑”。 安装 由于我目前没有注册成为开发者，插件还没发布到Chrome商店，所以只能用解压包安装。 首先进入页面：https://github.com/GooZy/tab-folder/releases，下载最新的压缩包到本地。然后解压它。 进入：chrome://extensions/，打开开发者模式，然后选择“加载已解压的扩展程序”，选择解压后的文件夹，即可完成安装。 最后 希望这款插件能戳到大家的痛点，欢迎提出意见~ 项目地址：https://github.com/GooZy/tab-folder ","link":"https://goozy.github.io/post/introduce-my-first-chrome-extension/"},{"title":"Chrome插件开发——踩坑记录","content":"记录一下最近开发中的坑点。 问题 后台脚本的persistent参数用处？ persistent属性定义了常驻后台的方式——当其值为true时，表示扩展将一直在后台运行，无论其是否正在工作；当其值为false时，表示扩展在后台按需运行，这就是Chrome后来提出的Event Page。Event Page可以有效减小扩展对内存的消耗，如非必要，请将persistent设置为false。注意，persistent的默认值为true。 https://www.cnblogs.com/giggle/p/8082672.html js脚本互相引用，报错：cannot use import statement outside a module 在manifest中注册所有脚本。如下，这样backgroud就可以引用utils里面的函数了 &quot;background&quot;: { &quot;scripts&quot;: [ &quot;js/common/utils.js&quot;, &quot;js/common/background.js&quot; ], &quot;persistent&quot;: true } 引入vue.js后，渲染文字失败 强制应用内容安全策略 (CSP) ，不能使用 new Function() 对表达式求值。 改用兼容版本：https://github.com/vuejs/vue/tree/csp/dist，缺点是目前只支持vue的1.x版本 或者使用vue-cli-plugin-chrome-ext开发 eslint 'chrome' is not defined 在package.json里面的eslintConfig添加&quot;webextensions&quot;: true https://stackoverflow.com/questions/48584556/eslint-chrome-is-not-defined-no-undef 使用chrome.extension.getBackgroundPage()获取后台脚本，长时间会失效，显示undefined 需要将persistent属性设置为true https://blog.csdn.net/jbk3311/article/details/103737039 IDEA报错，没有chrome 引入chrome库即可 https://stackoverflow.com/questions/13997468/how-do-i-use-webstorm-for-chrome-extension-development element-ui无法使用$message 需要注册Vue.prototype.$message = Message; https://www.jianshu.com/p/7e3e2041be39 vue默认标题修改 修改config里的template属性就行。把模板位置改成对应模块的index文件，然后更改index.html的标题 template: src/${name}/index.html Tips chrome://extensions/ 可以直接加载项目文件 “查看视图：背景页”，可以查看后台脚本的输出情况 使用vue-cli3开发：https://www.zhangshengrong.com/p/Mr1WyQxZNG/，https://juejin.im/post/5e59f8e65188254903694647 使用了：https://github.com/superoo7/vue-cli-plugin-chrome-ext ","link":"https://goozy.github.io/post/chrome-extension-development-problems-records/"},{"title":"说说HTTP和RPC","content":"最近被问到一个问题：“RPC和HTTP有什么区别？” 我说：“前者比后者效率高，但实现比较麻烦。总得来说后者比前者更“重”，导致效率低。” 回答的十分笼统，我觉得甚至没有解释清楚这个东西。 所以决定认真的再看看这两位“熟悉的朋友”。 HTTP 什么是HTTP？ HTTP是HyperText Transfer Protocol（超文本传输协议）的缩写。是一个应用层协议，规定了客户端（用户）和服务端（网站）之间请求和应答的标准，相互间通常使用TCP协议来进行连接，使用URI（Uniform Resource Identifiers，统一资源标识符）来标识资源。 URN和URL都是URI的表示形式。 URN（Uniform Resource Name，统一资源名称），为资源提供持久的、位置无关的标识方式，格式：urn:&lt;NID&gt;:&lt;NSS&gt; URL（Uniform Resource Locator，统一资源定位系统），用于标识互联网资源地址，完整格式：[协议类型]://[访问资源需要的凭证信息]@[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID] RPC 什么是RPC？ RPC是Remote Procedure Call（远程过程调用）的缩写。是一种服务器-客户端（Client/Server）模式，它允许一台计算机中的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序。 RPC通常包含传输协议和编码协议。 传输协议：HTTP，TCP等 编码协议：xml、json等 RPC是如何工作的？ 客户端调用客户端stub（client stub）。这个调用是在本地，并将调用参数push到栈（stack）中。 客户端stub（client stub）将这些参数包装，并通过系统调用发送到服务端机器。打包的过程叫 marshalling。（常见方式：XML、JSON、二进制编码） 客户端本地操作系统发送信息至服务器。（可通过自定义TCP协议或HTTP传输） 服务器系统将信息传送至服务端stub（server stub）。 服务端stub（server stub）解析信息。该过程叫 unmarshalling。 服务端stub（server stub）调用程序，并通过类似的方式返回给客户端。 为什么需要RPC？ RPC可以让不同的程序间进行交互，调用方式和本地方法调用一样，使用方便。 其传输协议可以使用传输层协议，比起网络层协议，效率更高。 结语 回到朋友最初的提问，这两者什么区别？一个是传输协议，一个是服务器-客户端模式，RPC可以选择在底层使用HTTP。 感觉把概念捋清了，很多东西就不言自明了。很多习以为常的概念，还是要多了解，最后内化成自己的东西，不然解释起来也是模棱两可XD。 参考 Hypertext Transfer Protocol 十分钟搞懂HTTP和HTTPS协议？ Remote procedure call 既然有 HTTP 请求，为什么还要用 RPC 调用？ - 易哥的回答 - 知乎 浅谈 RPC 和 REST: SOAP, gRPC, REST ","link":"https://goozy.github.io/post/talk-about-http-and-rpc/"},{"title":"[纯前端]打造自己的OKR管理软件","content":"OKR（Objectives and Key Results）即目标与关键成果法，可以理解为对目标完成情况的一种管理方法。 一般需要列出当前周期的目标，然后列举一些关键结果来衡量目标的完成情况。 我个人的情况是，以每两个月为一个周期设定自己的目标。最初都是用markdown记录，每次列出表格，写下目标，结果，进度，最后给自己算分数。 然而这个算分的过程每次都得重新计算，十分麻烦，而且表格也得手工维护，总之就是麻烦。于是就有了写个软件管理的想法。 正好自己主要是做后端，所以想学习下前端知识，于是把这款软件定位在web应用上。 1. 产品设计 先给自己写了个简单的PRD（产品需求文档），大概自己能看懂就ok，理了理思路。传送门 2. 环境配置 安装npm，获取npm 安装vue，官方安装方法 用IDEA作为IDE 3. 新建项目 使用命令vue ui开启图形界面，\b新建项目，有个默认初始化git选项，按照喜好可要可不要 “预设”选项，选择“手动”，然后勾上这些包vuex和router，不选包linter 之后勾选使用html5历史模式 进入项目web管理页面后，添加element-ui模块 项目建立后导入到IDEA，就可以开始编写代码了。 4. 难点记录 这一部分只挑一些重点来说，剩余的可以参考git仓库代码：ot 主要用了两个页面，App.vue作为整个门面，保持不变，主要用于展示OKR的可选月份，图中红色圈出的部分即是。Home.vue承接OKR的展示部分，为图中的非红色部分。 月份展示 提前算好月份列表，默认显示当前双月的目标。这里用v-model指定默认打开的tab。详细参考：官方文档-tabs 注意&lt;router-view&gt;别放在循环里面，这样会产生多个，实际上我们只需要一个。 数据传递 当点击月份标签的时候，使用$router.push把月份信息传递到Home.vue。这里有个点要注意，push方法在推送的URL和当前URL相同时，会在控制台报错。这里加了个catch忽略掉报错。 this.$router.push({path: '/okr/', query: {'month': tab.label}}).catch(() =&gt; {}); 由于使用的是同一个Home.vue，所以靠query词来区分页面。改写router/index.js来映射到Home.vue const routes = [ { path: '/okr/*', name: 'home', component: Home } ]; Home.vue考虑 本来只用了&lt;el-table&gt;，后来发现需要标题，所以在外面嵌套了&lt;el-card&gt;，最终布局是： 固定最后一行百分比 为了保证最后百分比总和为100%，就打算固定最后一行为不可更改的形式。 这里用了一个字典存是否可以修改hitBox: {}，key是目标+结果+列名，可以唯一确定一个单元格。 v-slot用于获取父组件的数据，使其可以传递下来，具体参考：编译作用域 数据刷新 有两种情况页面需要刷新。一个是当双击单元格时，此时要显示单元格成编辑框，所以必须刷新页面。另一个是数据变动时，此时需要刷新页面。所以要特别注意hitBox，在第一种情况下，不需要刷新，否则单元格又变回原样。 // 同样的页面，不需要初始化的数据 if (!isOldPage) { this.hitBox = {}; this.editData = false; } 数据直接用localstorage存，使用方式就是k-v，将结构化数据序列化后使用即可。 let tableData = localStorage.getItem(this.month); tableData = JSON.parse(tableData); 5. 部署到github pages 官方说的很明白：传送门 部署完之后就可以愉快地使用啦~ 6. 效果 项目github地址：https://github.com/GooZy/ot 部署页面：https://goozy.github.io/ot/ 参考资料 【2020版】4小时学会Spring Boot+Vue前后端分离开发 VUE+Element UI实现简单的表格行内编辑效果 Vue结合Element-UI实现单元格编辑、删除等操作 ","link":"https://goozy.github.io/post/make-your-own-okr-management-software/"},{"title":"时间管理工具——PlayTask安利","content":"今天给大家安利一款时间管理工具——PlayTask。 源起 大概是在16年知道的这款软件，当时用着感觉也还不错，私下安利给过一个朋友。之后由于自己的惰性，加上奖励项目设计的不合理，导致收支严重不平衡，最终被我卸载。 最近我又回坑了！因为时间完全不够用！！！ 想要学习，但是又忍不住看看看看看番，追追追追漫，玩玩玩游戏。 看到下面这些列表，我觉得不管管时间我真的要废掉了。 介绍 PlayTask和他的名字一样，就是让你像玩游戏一样完成任务。 想象一下现实世界就是一个大型RPG（角色扮演类游戏），而你就是这个世界的主角。现在你要在PlayTask上发布自己任务，任务完成会有奖励，而游戏中的奖励一般都是经验值、金币、物品。 这里经验值其实就是你完成任务的过程中自身的成长，比如背10个单词，你自身通过完成这件事，掌握了10个单词，这就是你完成任务获得的经验值。而金币呢？PlayTask允许你给自己发布任务的同时设定获得的金币个数，这样完成任务你就能获得金币奖励。 那么金币有什么用呢？金币可以用来购买物品，PlayTask允许自己设置奖励，来消费金币。 我辛辛苦苦赚的钱，当然是要大把挥霍啦，2333 这样整个RPG世界就构造完成~不过说到底现实本身就是个无法复活的RPG（大雾&gt;_&lt;） 另外，PlayTask还可以统计最近的消费情况，收支情况，很有意思呢。 技巧 由于自己有卸载重装的经历，说一下最近的使用心得吧。 不要超支，绝对不能让收入是负数，这是底线。 实打实一一记录，对自己没必要作弊。 任务与奖励要合理。目前我是粗略按时间划分金币获取数与消费数的，大概是1:3。比如学习半小时获得10金币，但是娱乐半小时需要消费30金币。\b金币收益具体也要和难度挂钩，越是不情愿做的，越可以给高收益。（比如这篇博文我给自己的收益是50金币，哈哈哈哈哈） 下载 目前IOS好像已经下架了，安卓还能在百度搜索到，不过最后更新也是19年4月份了，虽然副本功能用不了，但是用作记录的功能不受影响。 附一下下载传送门：https://pan.baidu.com/s/15Ta0KtISoJZzIKASv92tWw 密码:xkgh ","link":"https://goozy.github.io/post/recommend-a-time-management-tool-PlayTask/"},{"title":"如何用github和typora打造自己的云笔记","content":"缘起 从2016年冬季开始，我就有了看书会记些笔记的习惯，在比对了各个软件之后，选定了有道云笔记。主要看中了：1.免费；2.跨多个平台（手机、mac、windows）；3.可以用markdown写。 这几年用下来，确实也还不错。但总有一些让我不满意的地方，一是有时候卡顿严重，几乎无法书写；二是笔记的版本管理，我在mac上使用时，查看笔记的版本，虽然软件提供了比对近30天版本的功能，但是我发现各版本的区别就是0和1的区别（下图显示3-5号和3-3号两版本没任何改动，但其实我本身是有改动的）；三是我怕某天笔记倒闭了我这几年的笔记就得一个一个慢慢下载下来了，十分被动；最后一点就是有道云笔记支持不了本地图片添加到markdown里面； 所以渐渐地，我也有了把笔记上传github的想法。可是彼时github私有仓库是收费的，而我又不想私密的笔记公开，所以就作罢。但是现在不一样了，github私有仓库免费了，所以我也开始着手自己的转移工作。 所需工具 git，官网传送门：点我 开源的分布式版本控制系统 Typora，官网传送门：点我 Typora是一个本地的markdown编辑工具，支持Windows/Mac/Linux三大系统 步骤 1. 建立自己的github私有仓库 进入github官网，在个人仓库页面，新建私人仓库。 2. 克隆到本地 然后进入项目页面，克隆仓库到本地。 3. 设置Typora 主要就是开启Typora的文件树视图。 然后打开你的仓库。 之后所有的新建文件、目录操作都可以在文件树视图里面进行，不小心关闭了软件，只需要打开最近打开的文件，目录树自动就加载出来了。 总结 优点 本地图片放到同级目录下，就可以使用相对路径引入，在本地看笔记很方便。 所有笔记都在本地，同步到github，具有版本控制。 本地编辑，十分流畅。 缺点 同步github比较麻烦，需要自己提交至github。（可以自己写个crontab命令进行定时检测仓库变动，然后上传github） 笔记的分享功能没有了。（这个我个人的解决方式是发布到ubuntu pastebin进行分享，本来是想推荐gist的，结果被墙了=。=) ","link":"https://goozy.github.io/post/how-to-use-github-and-typora-to-build-your-own-cloud-note/"},{"title":"青岛中秋三日游","content":"前言 本来是想着中秋来一场说走就走的旅行，结果在询问秦皇岛和青岛哪一个比较好玩的时候，恰巧他们也打算去，此行就此成立~ 主要行程 青岛之旅(1/3)——亚美综合市场、劈柴院、栈桥海水浴场 青岛之旅(2/3)——浙江路天主教堂、栈桥、奥林匹克帆船中心、八大关、第二海水浴场 青岛之旅(3/3)——金沙滩 番外 本次出行，总共花费大概1300左右，大部头在来回的动车票上，其余花费我觉得性价比都十分高。 三天的行程结束，稍微认识了一座城，稍微认识了一群人。城市沿海真是老天莫大的垂帘。 旅行总是能发现各种各样的细节，不论是人还是城市。 海鲜这一趟真是吃到爽，便宜、好吃、量又多，2333。青岛的街道很小，小而精。这一趟之后，特别想去台湾看看，mark之。 Thanks♪(･ω･)ﾉ 广告时间 Java学习网站: ","link":"https://goozy.github.io/post/Travel-Around-Qingdao-20180922/"},{"title":"Arnold变换(附Python实现)","content":"介绍 首先是一个概念：置乱。意即将图像的信息次序打乱，使其变换成杂乱无章难以辨认的图像。 用处大概就是：对图像加个密，除非你暴力破解，否则你不知道这是个啥。所以就能安心地在百度云上存些蜜汁图片(≧▽≦)/啦 Arnold变换 也叫做猫脸变换，因为提出该算法的人当时是在一张猫的图片上操作，因此而得名= = 这个变换公式很简单： 这里N代表图像的长宽，意即需要是正方形。当然，如果你想在长方形上尝试，把长方形切割成多个正方形，分别对正方形操作即可。Xn和Yn是原图像像素点位置，Xn+1和Yn+1该像素点的新位置。 有两点十分神奇，我也不知道为什么： 单次变换后，所有像素点一一映射，也就是单映射。 经过一定的变换次数后，图像会变换成原来的样子。 算法实现大致思路 原图到新图就不说了，直接照着公式来。还原的话，只需要在公式两边乘上逆矩阵即可。 具体可以看代码的arnold和iarnold部分：传送门 参考资料 Arnold变换置乱图像 python中有关矩阵的创建、求逆、转置 百度百科：置乱 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/Arnold变换-附Python实现/"},{"title":"日本之旅(4.4~4.14)","content":"前言 北京室友大佬17年自己一个人去日本旅行过，今年旅行带上了我，程序宅于是有了一次出门~~（毕业旅行）~~的机会。 主要行程一览 日本之旅(1/11)——新宿御苑、六本木之丘、目黑川樱花 日本之旅(2/11)——明治神宫、上野公园、秋叶原 日本之旅(3/11)——江之岛、镰仓、涩谷 日本之旅(4/11)——河口湖 日本之旅(5/11)——银座、台场、浅草寺、秋叶原 日本之旅(6/11)——大阪城、圣玛丽号、海游馆、天宝山摩天轮 日本之旅(7/11)——大阪城御座船、通天阁、浪速之汤、日本桥 日本之旅(8/11)——京都。八坂神社、清水寺、平安神宫、哲学之道、京都御所、晴明神社 日本之旅(9/11)——伏见稻荷大社、二条城、岚山 日本之旅(10/11)——宇治。平等院、大吉山、造币局樱花道 番外 11天的日本之旅结束（最后一天其实也就是去免税机场，然后回国），程序宅仿佛打开了新世界的大门：“旅行好像也是不错的事情呢”。 从最初好奇，到现在的有所思，这段旅程收获还是颇丰的。最明显的一点就是，让我更想好好地游览自己的祖国了。我想知道幅员辽阔的中国，究竟是怎样一番模样。 套用在造币局樱花道听到的一句日语：这样的感觉啊，还是第一次呢。以后也请好好旅行吧~ 这次的全部基本花费，即不可避免的花费：将近8000+ RMB 日本上班族大部分都是西装革履呀。小学、中学、高中，也都是一路制服下来，怎么说呢，感慨吧，虽然制服好看，但是觉得有些拘束。 日本修学旅行真棒呢，这几天天天都能见到学生们，啊，青春啊？！ 日本的井盖，嗯，怎么说呢，井盖不要钱系列，各个地方的都有自己特色。 日本神社真的很多！ 关东扶梯靠左，关西扶梯靠右（然而关西有些地方又靠左），果然最正确的做法是跟着第一个人做 日本环境保护以及文化开发是真的好，很宜居。 但是啊，我真的吃不惯日式料理，还是中华料理第一！ 动漫人物喜欢的食物= =请一定不要抱太大希望尝试。 教练，我想学日语！教练，我想学英语！ 御守狂魔推荐御守购买：江之岛某款全蓝的御守，音羽山（清水寺）的樱铃。（可惜我都没买，果然人生看到喜欢的东西当时就要去追求~） 旅行推荐：明治神宫、秋叶原、江之岛、镰仓稻村崎站（踩沙滩）、河口湖、台场海滨公园、海游馆、天宝山摩天轮、浪速之汤（温泉赛高）、清水寺、哲学之道、伏见稻荷大社、岚山、大吉山 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/日本之旅-4-4-4-14/"},{"title":"光学字符识别-闲谈3","content":"本期题目 在给出的10000张图片中，有一个单词重复出现了两次，请找出这个单词~ 来源：千里码 → 传送门 正经 首先当然是下载文件包，看看需要识别的都是什么图片啦。发现大部分都经过了旋转，变形倒没有，所以可以说是省下很大一笔功夫，然后调用开源的Tesseract-OCR愉快地识别。所以重点应该就是在如何把图片旋转回来:p 先交代下我旋转前的前置步骤，放大-&gt;灰度-&gt;二值，OpenCV轻松完成。 然后来个巨模糊的高斯模糊，主要就是为了让图片糊在一起，二值化后就只剩一个椭圆形轮廓。然后找到该轮廓的最小外接矩形，如果该矩形旋转度数为0，则不进行后续操作。否则，我们就去找矩形的上方、下方、左方、右方顶点。 有了这四个顶点后，根据上方和下方顶点的相对位置，我们就能判定矩形到底是怎么斜的了，无非两种情况：k &gt; 0 || k &lt; 0。这个斜率k呢，我们可以用两条短边的中点算出来，这样倒着旋转度数，就可以开心地得到正常角度的单词啦(≧▽≦)/这里要注意OpenCV的坐标系，否则容易搞错顶点，如下图： 最后就是愉快的识别啦，首先直接拿下载的Tesseract-OCR进行识别，结果惨不忍睹，然后发现可以限定只识别小写字母以及单行处理，结果也是bad。无奈ㄟ( ▔, ▔ )ㄏ，只好自己动手，丰衣足食，进行训练，训练要记住的要点就是：找到26个字母都在训练集里就行！哇，我随机找了50张，标完了才发现还少了几个字母，被自己蠢哭TAT 闲谈 17年年末的夙愿=。=，结果拖到了现在才做完。当初大一数字识别各种网上找资料，MFC简直反人类。工作后接触比较多的就是OCR了，证照识别，验证码识别，不过仅仅都如前文所说，只是尽力做些预处理，真正核心的识别原理还没时间去了解，这个下来自己也想好好看看，嘿嘿😜 本期代码链接 → 传送门 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/光学字符识别-闲谈3/"},{"title":"无边界地图[闲谈2]","content":"本期题目 一起来玩生命游戏~ 这是一款二维平面游戏，模拟生命的演化过程，规则十分简单： 如果一个生命体周围少于2生命体，那么该生命体会因为人口缺少而在下一轮死去，这个格子变成了空地。 如果一个生命体周围大于3个生命体，那么该生命体会因为人口的过度拥挤，资源匮乏，而在下一轮死去。这个格子变成空地。 如果一个生命体周围有2-3个生命体，那么该生命体能在下一轮继续活下去。 如果一个空地周围有3个生命体，那么该空地在下一轮会繁殖出新的生命体 总结起来就是：有生命的格子，仅当周围存在2~3个生命体才能存活下来；无生命的格子，仅当周围有3个生命体，才能孕育出生命。 维基百科上的动图十分生动，可以看看 https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life 这次的任务是给出初始的五个格子，说出在第几轮的时候，演化出最多的生命体 来源：千里码 → 传送门 正经 首先看看这个图是怎么演化的 传送 各种方向四处飞，初始化个很大的地图模拟过程应该是不行了= = 考虑上方自己写代码的时候，其实用到的只有生命体和它周围的8个格子，那么是否可以只存下这些生命体的坐标位置？ 最终方案为：字典键记录生命体坐标，值记录周围生命体个数，每次迭代做一次备份，循环演化即可。 闲谈 生命体游戏啊，很早就想写一个了，理想中是写个图形界面的，这次用控制台输出感觉也不错，哈哈哈。 感觉题目介绍的无边界地图和我的认知稍微不同。个人认为的无边界是伪无边界，程序本身有存一份很大的地图，然后随着角色的走动，动态加载其中的一部分。 本题给我的感觉是只记录必要信息= = 来张帅气的控制台图： 本期代码链接 → 传送门 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/无边界地图-闲谈2/"},{"title":"动态爬虫[闲谈1]","content":"开题介绍~ 打算开一个“闲谈”专题，定期(不定期?)收录一些自己觉得有趣的题，记录解题过程~ 本期题目 一共有十个时刻变化的页面，他们的更新频率不尽相同，需要给出这十个页面的频率排序 来源：千里码 → 传送门 正经 分析题目，大概就是需要做两件事情：比对页面是否相同、调整爬取频率 需要比对同一页面差别的话，那可以考虑计算整个页面的md5值，这样就可以直接看出差别。谈优化的话，我觉得可以去除所有对人眼识别不相关的元素之后进行md5，比如页面空格。 爬取频率调整，感觉可以考虑参考TCP拥塞控制那样，初期成倍增长，当页面变化时停止成倍增长，转而变成1.1倍的增和减。 十个页面的话，开十个进程嘛，妥妥的:p 然后就放着跑等结果吧，2333 闲谈 感觉爬虫的频率适配是个不错的想法，每个页面使用不同的频率爬取，节约资源。不过对于垂直爬虫这一类别，个人感觉还是不适用，还是根据网站量级制定频率比较稳妥= = 诶，这么想的话，垂直爬虫只要能够制定一个网站的判重规则不就行了么，嘿嘿= =哇，这能怎么做。。。。。。 本期代码链接 → 传送门 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/动态爬虫-闲谈1/"},{"title":"图数据库Neo4j总结","content":"前言 最近业务上需要表现一些数据间的层级关系，考虑到关系型数据库的联表查询随着量级增大，复杂度骤增，打算采用图数据来存储这一部分数据用于展示。 介绍 Neo4j是一款开源的图形数据库，以图形结构的形式存储数据。 下载地址：https://neo4j.com/download/other-releases/#releases 解压后进入目录输入：./bin/neo4j console 即可启动，初始账号密码均为 neo4j 也可以直接在线尝试：https://neo4j.com/sandbox-v2/?ref=product 与关系型数据库对比 关系型数据库 图数据库 表 标签（每个节点都有自己所属的标签，标签内的节点可以看做一个组，单个节点可以拥有多个标签，上方财政部的标签就是Person） 行 节点（节点记录着节点属性，单个节点拥有多个属性（建议越少越好，因为主要关注在点与点间关系上）） 列 属性名 表间关系 节点间关系（关系带有标签，一个标签下可以有多个属性值，例如上方的参股就是一个关系标签） SQL Cypher（专有查询语言） Cypher 总：http://neo4j.com/docs/cypher-refcard/3.0/ Cypher命令不区分大小写，但是属性值是区分的 增 CREATE (a:Person { name: &quot;Guo&quot;, from: &quot;China&quot;, age: 22 }), (b:Person { name: &quot;Zi&quot;, from: &quot;China&quot;, age: 22 }), (a)-[r:Knows {since: 1995}]-&gt;(b) RETURN a, r, b 建立一个标签为Person，具有三个属性name、from、age的节点，a为变量名。然后建立两者的单向关系，其中Knows为关系标签，具有属性since。使用()来表示节点，{}表示节点属性 查 MATCH (a:Person), (b:Person) WHERE a.name = &quot;Guo&quot; AND b.name = &quot;Zi&quot; return a, b; 删 MATCH (b:Person) WHERE b.name = &quot;Zi&quot; DETACH DELETE b; DETACH会删除节点及与该节点相关的关系 改 MATCH (n) where n.name='Guo' set n.Company='Team' return n; 与Python交互 总：https://neo4j.com/docs/api/python-driver/1.5/ 官方有提供驱动，但是我更推荐使用py2neo，使用起来更便捷 py2neo(3.0版本)：http://py2neo.org/v3/ 增删改查 from py2neo import Graph, Node, Relationship graph = Graph( &quot;http://localhost:7474&quot;, username=&quot;neo4j&quot;, password=&quot;000000&quot; ) # 增 father = Node('Person', name='A') child = Node('Person', name='B') graph.create(father) graph.create(child) graph.create(Relationship(father, 'Father_of', child)) # 改 father['name'] = 'C' graph.push(father) # 查 x = graph.find_one('Person', 'name', 'C') # lable, key, value # 删 graph.delete(x) 关系数据库导入到图数据库 参考：http://paradoxlife.me/how-to-insert-bulk-data-into-neo4j 对于少量数据（文件必须放在neo4j的impot目录下） load csv with headers from &quot;file:///clue_invest.csv&quot; as line merge (p:Invest{company_name: line.company_name, name: line.name, level: line.level}) 对于大量数据，可以考虑生成csv导入（header和数据分开有利于后期更改） 可以参考：http://blog.csdn.net/macanv/article/details/78296066 命令不要加多余空格，另外neo4j-import之后会考虑废弃，所以推荐使用neo4j-admin来进行 /Users/guoziyao/Desktop/neo4j-community-3.3.0/bin/neo4j-admin import --mode csv -nodes:Company company_header.csv,company.csv --nodes:Person person_header.csv,person.csv -relationships relationship.csv 总结 以上便是这段时间学习的一个总结，更多的用法可以查看官方文档，以及给出的一些参考:) 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/图数据库Neo4j总结/"},{"title":"从今天开始使用HyperComments啦！","content":"UPDATE 2018.05.30 HyperComments将于2018.06.15起不再提供免费服务。需要免费评论系统的，可以参考这篇文章“Gitment：使用 GitHub Issues 搭建评论系统”了。目前博客将采用gitment作为评论系统，有疑问的可以到留言页留言，旧文章不再提供评论，新文章可正常评论。 UPDATE 2018.09.27 如今giment也GG了，正式换成valine，顺带把主题升级到6.x了，累=。= UPDATE 2019.06.01 改用gridea管理博客了，挺好用的，现在的评论系统是内置的gittalk。 参考资料 Гиперкомментарии для темы Next в Hexo 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/use_hypercomment_from_today_on/"},{"title":"Java泛型中的通配符","content":"最近想学学集合框架的源代码，结果画风是这样的： boolean addAll(Collection&lt;? extends E&gt; c); default boolean removeIf(Predicate&lt;? super E&gt; filter) { ... } boolean containsAll(Collection&lt;?&gt; c); 一下就暴露了泛型没好好学的锅= =，今天总结一下。 下文统一使用这两个类进行说明。 class Fruit {} class Apple extends Fruit {} 泛型中的通配符 上边界限定通配符 用法：&lt;? extends Fruit&gt; 即当前类型 X = ? extends Fruit，类似X &lt;= Fruit的感觉 这个X类型，表示是某个Fruit子类(或者Fruit本身)的类型，这也就意味着X类型有多种可能性，而编译器无法判定是哪一个类型，所以通过这种方法声明的List无法添加元素，只允许取出元素，取出的元素全都会向上转型。 下边界限定通配符/超类型的通配符 用法：&lt;? super Fruit&gt; 即当前类型 X = ? super Fruit，类似X &gt;= Fruit的感觉 这里的X类型，表示是某个Fruit父类(或者Fruit本身)的类型，虽然这里的X的类型也有多种可能性，但是编译器可以断定，只要加入的类型是Fruit子类或者Fruit本身，就一定可以向上转型。所以通过这种方法声明的List允许添加Fruit及其子类型的对象，加入的对象会自动向上转型成Fruit。 与上边界通配符的配合： class Test { public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) { for (int i = 0; i &lt; src.size(); i++) dest.set(i, src.get(i)); } } 无边界通配符 用法：&lt;?&gt; 即当前类型X不限定范围，可能是任意的一个类型。所以自然也就无法向其添加任何元素了。用法类似于extends，不过get出来的是Object类型就是了。 PS 引子中的removeIf是一个默认方法，不得不赞一发，既扩展了接口方法，又不使得实现接口的类去添加新方法的覆盖，具体见参考资料。之后别人再问接口和抽象类的区别，就不能说普通类实现接口一定要实现所有方法了，2333。 参考资料 Java 泛型总结（三）：通配符的使用 Java 8 默认方法（Default Methods） 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/Java泛型中的通配符/"},{"title":"关于Java中parseInt的一个趣事","content":"今天看Java的时候突然好奇parseInt()的实现，想着会不会和自己平常比赛时候的实现方法一样。于是就翻到了这个： public static int parseInt(String s, int radix) throws NumberFormatException { /* * WARNING: This method may be invoked early during VM initialization * before IntegerCache is initialized. Care must be taken to not use * the valueOf method. */ if (s == null) { throw new NumberFormatException(&quot;null&quot;); } if (radix &lt; Character.MIN_RADIX) { throw new NumberFormatException(&quot;radix &quot; + radix + &quot; less than Character.MIN_RADIX&quot;); } if (radix &gt; Character.MAX_RADIX) { throw new NumberFormatException(&quot;radix &quot; + radix + &quot; greater than Character.MAX_RADIX&quot;); } int result = 0; boolean negative = false; int i = 0, len = s.length(); int limit = -Integer.MAX_VALUE; int multmin; int digit; if (len &gt; 0) { char firstChar = s.charAt(0); if (firstChar &lt; '0') { // Possible leading &quot;+&quot; or &quot;-&quot; if (firstChar == '-') { negative = true; limit = Integer.MIN_VALUE; } else if (firstChar != '+') throw NumberFormatException.forInputString(s); if (len == 1) // Cannot have lone &quot;+&quot; or &quot;-&quot; throw NumberFormatException.forInputString(s); i++; } multmin = limit / radix; while (i &lt; len) { // Accumulating negatively avoids surprises near MAX_VALUE digit = Character.digit(s.charAt(i++),radix); if (digit &lt; 0) { throw NumberFormatException.forInputString(s); } if (result &lt; multmin) { throw NumberFormatException.forInputString(s); } result *= radix; if (result &lt; limit + digit) { throw NumberFormatException.forInputString(s); } result -= digit; } } else { throw NumberFormatException.forInputString(s); } return negative ? result : -result; } 整体思路也是先乘基数，然后加值，多了对溢出的判断。在计算结果时，不是像我平常使用正数存储，而是默认是负数。不是很理解，然后注释说防止接近MAX_VALUE。发现：INT_MAX = 2147483647 、 INT_MIN = -2147483648。那么答案就很明显了，如果默认为正数的话，当值为INT_MIN时，会造成溢出，最终异常。好严谨Orz 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/关于java中parseInt的一个趣事/"},{"title":"GitHub入门与实践 笔记+书评","content":"笔记 git diff HEAD (查看本次提交和上次提交的区别) git reset --hard hashValue 回退到哈希值对应版本。这条命令会把你工作目录中所有未提交的内容清空(当然这不包括未置于版控制下的文件 untracked files) git checkout -- xx.txt 恢复单个文件 git commit --amend 修改最近一次的提交信息 git commit -am '...' 个别文件修改时，直接这样，省事。 分支操作 git branch (显示分支一览表) git branch xxx (创建分支xxx) git checkout xxx (切换到分支xxx) git checkout -b xxx (上方两命令的合成) git checkout - (切换回上一个分支) git merge --no-ff xxx (合并xxx到当前分支，关闭fast-forward，保留commit历史) git branch -D xxx 删除分支xxx git branch -a (查看所有分支) git branch -r (查看远程分支) git reflog (查看当前仓库的操作日志) 发送pull request 首先网页上fork 然后git clone git@github.com:username/proName 创建特性(Topic)分支。 git checkout -b work xxx(xxx为源分支) 修改文件 git diff查看修改是否正确进行 全部确认完毕后提交到本地仓库。git add xxx 和 git commit -m 'xxx' 由于目前只建立了本地的分支work，还需在远程建立此分支。git push origin work 在远程建立这个分支。 从网页进入分支。提交PR git fetch xxx 更新分支xxx到最新版本。此时需要手动进行merge。这种做法比较安全 接收pull request 首先，我们把接收方仓库clone到本地。已经clone过的，就通过pull更新到最新版。 然后，把发送方的仓库设置为远程仓库(git remote add name git@github.com:prSender/repoName)。接着fetch到本地。 建立一个分支merge刚才fetch的内容。接着就是看看程序是否没有问题。 没问题，你就把这个分支删了吧。 最后到网页接收PR即可。 当然，也可以切换到主分支，进行合并，然后push到github，此时PR会自动关闭。 与github相互协作的工具或服务 hub。完全包含git的所有命令，并且对其进行了简化和扩展。 Travis CI(Continuous Integration)。可以在开发者执行提交后立即进行测试和构建。Travis Weblint检查配置文件.travis.yml是否错误。有些仓库的readme中显示有些条状状态，正是Travis CI的测试结果的显示。 Coveralls。代码覆盖率检测服务。 Gemnasium。查询github仓库正在使用的RubyGems或npm(Node Package Manager)，让开发者了解自己是否正在使用新版本进行开发。 Code Climate。只支持Ruby，提供代码分析报告服务，对代码质量进行评定，指出质量有问题代码。收费。 Jenkins。持续集成开发服务。主要用于持续、自动地构建/测试软件项目和监控一些定时执行的任务。 书评 这本书可以算是一本工具书+经验书。 书中有很多的命令，所以记笔记是必须的。另外作者也会根据自己的经历给出一些开发中需要注意的事项。对于入门而言我觉得是极好的一本书，剩下的提高就要看自己之后的实践了。此外书不大，作为参考书放着也是极好的。 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/GitHub入门与实践-笔记-书评/"},{"title":"Codeforces 706E Working routine (模拟链表)","content":"题目链接： Codeforces 706E Working routine (模拟链表) 题意分析： 给出一个矩阵和q个操作，每次操作需要交换矩阵的两个子矩形，问：经过q次操作后，最终矩阵长什么样子。 解题思路： 1000×10001000 \\times 10001000×1000 的矩阵啊，n2n^{2}n2 操作肯定是要T的。考虑链表将整个矩阵串在一起，如下图： 发现对于任意需要我们交换的矩阵，其实我们只需要改变这两个矩阵的周围一圈元素的指针指向即可完成两个矩阵的交换。单次操作复杂度就降到了O(n + m)了。另外我们只需要知道元素的右边下边是什么，并不用关心上方，左方是什么，所以只用存储两个方向即可。 个人感受： 链表赛高！ 具体代码链接： 传送门 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/Codeforces-706E-Working-routine-模拟链表/"},{"title":"HDU 5812 Distance","content":"题目链接： HDU 5812 Distance 题意分析： 给出一个空集合和三个操作。操作I向集合中插入元素X，操作D删除集合中的元素X，操作Q，查询集合中与X的最小距离最小是多少？ 定义最小距离 d(x,y)d(x,y)d(x,y) 为从x变为y只通过乘或者除素数所需要的最少操作。例如：d(15,50)=3d(15, 50) = 3d(15,50)=3，因为 15/3×2×5=5015 / 3 \\times 2 \\times 5 = 5015/3×2×5=50 解题思路： 求d函数第一反应就是把两个元素分解成质因数，然后去掉公共的部分，剩下的就不是公共部分，必须通过乘法和除法才能变为对方。所以有 d(x,y)=f(x/gcd(x,y))+f(y/gcd(x,y))d(x,y) = f(x / gcd(x,y)) + f(y / gcd(x, y))d(x,y)=f(x/gcd(x,y))+f(y/gcd(x,y)) 其中 f(x)f(x)f(x) 是该数的质因子个数。（看到式子感觉确实挺显然的，但比赛中去掉公共部分后就没怎么往这方面想） 考虑枚举x的约数，那么现在问题就在于如何快速的对整个集合中的可行元素求出 f(y/gcd(x,y))f(y / gcd(x, y))f(y/gcd(x,y)) 显然，此时只有集合中是约数倍数的数才需要被考虑（这样才能和x一样整除约数）。 尝试定义数组d[i]，代表集合中以i为约数，能达到的最小f值。那么每加入一个集合中不存在的值X，我们就能将X进行约数分解，比如分解成了 X=y×zX = y \\times zX=y×z，那么就能这么更新: d[y] = min(d[y], f[z]); d[z] = min(d[z], f[y]); 然而这样存在一个问题，当能得到最小值的那个元素被删除后，d[]数组的值就不知道该怎么更新了。也许可以记录次小值，那如果次小被删除呢？第三小？所以显然要转换下策略。 由于对于一个数x，他的质因数个数不超过20个（220=10485762^20 = 1048576220=1048576），所以我们直接把所有可行值存下来，然后遍历二进制位，找到最小的那一位1所在位置，就是d[]数组对应的值了。所以我们d[]数组存放二进制即可。比如d[3] = 0000101010,那么最小的f值就是1了。 最后我们开个二维数组c[i][j]：记录约数i能得到的f值j出现的次，用它来维护d[]数组的更新即可（次数为0说明不存在了，要剔除）。 个人感受： 这场多校题感觉都好劲啊，那种细细读题解，然后恍然大悟的感觉，那道炉石的DP也是。不像有些场，看了题解一脸懵比。 具体代码链接： 传送门 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/HDU-5812-Distance/"},{"title":"2016 Pre-summer Training Ⅳ - Data Structure","content":"前言 数据结构亦可赛艇！我已经中了树的煮粥XD坐等官方题解，学习一波剩下的题Orz 丧病韬面向AC出数据，至今不会那题TAT B. 发糖游戏1+1 题意 两种姿势发糖，具体看题目描述= = 分析 线段树 单点更新，区间查询 + 区间更新，单点查询 思考 坑点： 无。 技巧： 基础。 E. 组队方案数 题意 寻找公比为k的三个数的个数（这三个数根据相对位置从左到右排列）。 分析 找等比数列。相对位置确定，如果当前数字为x，那么我们从后往前统计的话，就能知道有多少个kx，顺带也能统计出kx之后有多少个kkx。使用两个map，一个存kx，一个存kkx。2. 设两个map分别为ans和cnt，ans[i]记录i和i×ki\\times ki×k的组合个数，cnt[i]记录到目前位置i出现了多少次。 所以有转移： 答案 += ans[当前值 ×k\\times k×k]; ans[当前值] += cnt[当前值 ×k\\times k×k]; ++cnt[当前值]; 思考 坑点： 公比为0、1之类的。之前转移没考虑清楚还特判这种情况，现在的转移不需要特判。 技巧： 思考。 F. goozy挑战最强大脑 题意 初始总值为1，操作1：总值乘X，操作2：总值除第X次出现的乘数。给出每次操作之后总值模72807249之后的值。 分析 除一个以前乘的数，相当于那个数变成了1。 线段树单点更新，区间查询。 思考 坑点： 区间查询用query会慢，由于是总区间值，直接输出sum[1]就好了。 技巧： 转换思维。 G. 线段树写个爽 题意 如题，各式区间更新。 分析 操作1需要全部加上一个值c，最基础的区间标记。 操作2标记区间左值和右值以及公差 操作3标记是否转换即可 操作4，区间查询 思考 坑点： 记得开long long啊，不然WA个爽！另外细节要考虑清楚！ 技巧： 凡是涉及到修改数据的操作，都要标记下传。如果有操作3存在，那么它之前的其它操作都无效。 H. 这是一个标题 题意 求区间最大连续和。 分析 三个标记，lsum从左开始的最大和，sum区间最大和，rsum从右开始的最大和。区间合并经典题。 思考 坑点： 无。 技巧： 设定状态，好好转移。 K. 这是一颗普通的树 题意 这是一颗普通的树，普通到需要树链剖分才能解决。 分析 树链剖分之后就是基础的线段树操作了。 思考 坑点： 无。 技巧： 树链剖分。 L. 数列维护 题意 完成对数列的五种操作。 分析 splay。推荐hiho一下 104 周和 105 周的splay专题。 基于splay的特点，每次都能将需要操作的一段区间旋转到特定子树上，所以操作就好进行了。 思考 坑点： 无。 技巧： splay。 具体代码点击下方传送门:) 传送门 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/2016-Pre-summer-Training-Ⅳ-Data-Structure/"},{"title":"hiho计划之hiho一下","content":"打算有空就做下hihocoder，算是 复习 + 学习 吧 😃 hiho一下第1周——最长回文子串 Code + Note hiho一下第2周——Trie树 Code + Note hiho一下第3周——KMP算法 Code + Note hiho一下第4周——Trie图 Code + Note hiho一下第5周——数字三角形 Code + Note hiho一下第6周——01背包 Code + Note hiho一下第7周——完全背包 Code + Note hiho一下第8周——状态压缩·一 Code + Note hiho一下第104周——平衡树·Splay Code + Note hiho一下第105周——平衡树·Splay Code + Note 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/hiho计划之hiho一下/"},{"title":"Union Training III - Graph Theory","content":"前言 图论专题结束！数据库课设也只剩下小修小补，GJ！总结这次专题：见多识广，建多识广。抓紧在暑假前搞定那本书！ A. Euler 题意 判断一幅图，如果是无向图是否存在欧拉通路，如果是有向图，是否存在欧拉通路 分析 无向图：G 为连通图，并且 G 仅有两个奇度结点（度数为奇数的顶点）或者无奇度结点。 有向图：D 为有向图， D 的基图连通，并且所有顶点的出度与入度都相等；或者除两个顶点外，其余顶点的出度与入度都相等，而这两个顶点中一个顶点的出度与入度之差为 1，另一个顶点的出度与入度之差为-1。 思考 坑点： 对于孤立点，教材说法不一，导致歧义。 技巧： 记住判断方法。 B. -0你电脑炸啦 题意 任务窗口只会在给定的位置出现，需要做的就是判定当前图像是否合法。 分析 图中需要我们找矛盾！ 如果A窗口被B窗口覆盖，那么就连一条边A-&gt;B，如果B窗口又被A窗口覆盖，那么连一条边B-&gt;A。建完图后，判断是否有环即可判断是否存在矛盾。 思考 坑点： 没有吧，可能原题卡暴力了，然而我没卡= =让大家错失了一次锻炼自己思维的机会啊，23333 技巧： 建图建图，建多识广。 C. 寻找fly真迹 题意 构造一个字符串，使得把它的每个字符抽象成点，相邻字符连边能构成题目所给出的图。 分析 注意只有a,b,c三个字符！b字符和任何字符都相连！ 于是，b肯定是度数为n - 1的点。剩下的就是a和c怎么安排了，从点1开始，如果没有被赋予字符就赋予字符a，然后dfs把和a以及任何a所能到的没有赋值的字符赋值为a，因为a能够相邻的只有a和b。完毕后还有字符，那么就赋值c，过程同上。（二分图染色的感觉，最后用构造出来的串比对原图即可） 思考 坑点： 很机智啊。 技巧： 就看你机智不机智了。 D. 一食堂 or 二食堂， it's a question 题意 求任意两个人到食堂的距离加上他们两人所在食堂距离之差的和的最大值的最小值。他们间有喜欢/讨厌的关系，使得要/不要在一个食堂用餐。 分析 最大值的最小值，二分既视感。 知道了答案有什么用呢？可以制造矛盾了。我们定义disA、disB分别为A、B两位同学各自到某个食堂的距离，disAB为两者所在食堂距离，如果disA + disB + disAB &gt; 答案,那么显然这是不可行方案，所以可以推出：A去自己当前选择的这个食堂，B必须去B自己当前选择的另一个；或者B去自己当前选择的这个食堂，A必须去A自己当前选择的另一个；这里只是依据矛盾推出一些东西而已。然后再根据互相喜欢的人建立矛盾，互相讨厌的人建立矛盾。用tarjan判断矛盾是否在一个连通分量内即可。这就是所谓的2-SAT。 思考 坑点： 啊啊啊，我WA 10 发，简直啊！！！对出题人深深地唾弃= =不管怎样，反正他缩点写错了无误，TAT。 技巧： 找出矛盾，建边，判断连通分量。 E. Division 题意 不可重点的最小路径覆盖。 分析 缩点，然后二分图匹配。 二分图中，最小路径覆盖 = 点个数 - 最大匹配数 思考 坑点： 没有。 技巧： 见多识广。 F. meixiuxiu学图论 题意 找图中环上边权最大值的最小值。 分析 啊，我各种缩点，各种GG。 正解：先最小生成树，标记树上的边。然后不断添加未标记的边，显然，每加入的边必定都会构成环，而由于是最小生成树，所以新加的边一定是环上的最大值，所以拿答案和新加的边不断比较即可。 思考 坑点： 没有。 技巧： 啊，太美妙了~ G. 最短路 题意 统计图中不重边的最短路个数。 分析 不重边呀，所以说每条路径的贡献就是1咯，流啊流啊流的感觉~ 想当初第一次做真是一脸蒙蔽啊= =。正解：跑最短路，把所有最短路的边留下来，然后在新图中最大流即可。 思考 坑点： 没有。 技巧： 建多识广。 H. NightMare2 题意 在不爆炸的前提下拿最多的宝藏。 分析 二话没说，感觉可能是先跑最短路，然后根据最短路答案调整的题。写完发现不对，最短路得到的宝藏数和答案没啥关系啊= =然后苦思，结果见2。 突然问自己，能不能二分？然后就出结果了= =。其实换句话说，就是在规定时间内，从起点到终点最可能经过的最小上限的路能多大？ 二分宝藏价值，然后跑最短路。 思考 坑点： 没有。 技巧： 转换思维。 I. 玛雅，好简单 题意 输出一张无向图中的桥边的数目。 分析 题目太直白了，上tarjan。诶，答案怎么老是不对。啊！按点标记有问题啊TAT，怎么办！怎么办！ “诶，郭**，你看看我这错哪了？”xf如是问我。“诶，你怎么标记边啊。”，对哦，标记边啊！ 思考 坑点： 没有。 技巧： 转换思维。 J. An Easy Problem 题意 可重复点的最小路径覆盖。 分析 和E题很像有木有，像归像，然而还是有区别。 其它和D题一样，不过建立二分图的时候要传递闭包。 思考 坑点： 无。 技巧： 见多识广。 K. 投票 题意 每个人都能给他所能直接或者间接相连的人投一票，问：得票最多的人是几号人物？如果有多个，就按升序输出他们的号码。 分析 缩点得到DAG。得到新图。然后新图中每个点向所有直接或者间接连的点投票，票数为连通块内点个数。最终得票数就是：从其它人那边得到的票数 + 自身连通块内得到票数 思考 坑点： 无。 技巧： 缩点 + 大胆。 良心话： 缩点之后，最坏情况O(n^2/2)，就是一条链的情况。所以这种解法理论上还是会T的，好奇正解是啥。 L. Cruel War II 题意 能否用不超过10个的点覆盖完整幅图的所有路径。 分析 哦~我百度了一发一般图的最小点集覆盖，找到了一篇论文，实现了它，然后被自己一个五个点的样例叉掉！咦，原来是n^2求近似解啊！！！ fly说搜索，按边搜，意淫半天，终于过了。 具体就是dfs(p, use)代表到边p，标记了use个点，如果这条边的任意一个点被覆盖了，就继续dfs(p + 1, use)，否则枚举两个点的选与不选。 思考 坑点： 让人以为是NP难题啊！ 技巧： 读题 + 思考。 M. interesting 题意 大概就是问无数个a1~an能构成多少个Bmin到Bmax中的数？ 分析 我的做法是对这几个数从小到大排序，取最小的非0的数，那么所有能构成的数都能分解成：0+k×ami,1+k×ami,...,ami−1+k×ami0 + k \\times ami, 1 + k \\times ami, ... , ami - 1 + k \\times ami0+k×ami,1+k×ami,...,ami−1+k×ami。然后只需要求出每个剩余结果的最小的那个值是多少就行啦。比如样例，0的最小是0，1的最小是10，2的最小是5。 然而我WA了= = 思考 。。。。。。。。。。 具体代码点击下方传送门:) 传送门 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/Union-Training-III-Graph-Theory/"},{"title":"CQU&SCU Union Training II - Dynamic Programming","content":"前言 DP专题。斜率优化，单调队列，还有各种迷之姿势，反正这个专题我是废了Orz。 A. 雷神之路 题意 询问从0到n一共有多少种走法，每次可以走1、2、3步，有些点不能走。(1≤n≤10181 \\leq n \\leq 10^181≤n≤1018) 分析 很容易想到dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]，然后地雷点dp[i] = 0。 华丽丽的由于矩阵乘法矩阵位置不对debug了好久。另外一直不知道怎么处理地雷，其实地雷就是原先的矩阵得出的下一个的值为0，那么根据这点构造地雷矩阵即可。 思考 坑点： 无。 技巧： 使用矩阵快速幂。分A类矩阵、B类矩阵计算。 C. TaoSama与煎饼 题意 煎饼工作台有(1≤n≤3501 \\leq n \\leq 3501≤n≤350)的格子，煎饼通过每个格子会提升口感ai，初始时煎饼在位置1，所以初始口感度为a1。然而煎饼不能自己移动，必须使用Taosama的(1≤m≤1201 \\leq m \\leq 1201≤m≤120)个小道具才能移动，每个小道具只能使用一次，每次移动距离bi(1≤bi≤41 \\leq bi \\leq 41≤bi≤4)，保证同样距离的小道具总数不超过40。 分析 格子，移动，第一个想法是背包，开搞，答案怎么不对= =额，使用顺序会影响结果啊！ZZ。 怎么存这顺序呢= =，重新看题目，移动距离1到4，不超过40，关键字啊，新状态dp[i][j][k][l]移动到i使用了第一个、第二个、第三个道具的数量，嗯，第四个相减就能出来嘛~不过这种状态爆内存啊！GG。 问fly我爆内存了咋办，他说开三维就够了。于是豁然开朗，第一维位置没用啊！然后搞，诶，怎么样例二答案不对= =。左思右想，不对啊，得四维，第四个道具不能由前三个计算出来，算了下不会爆内存，搞！然后AC了~ 思考 坑点： 没有吧 技巧： 正如PPT所说，不管别的，状态开出来再说，优化等开出来后再考虑。 E. Goozy的积木 题意 用(1≤n≤501 \\leq n \\leq 501≤n≤50)个积木，最高能搭建多高的两个塔？ 分析 这不正是ppt上说的那道题吗？dp[i][j]代表到第i个积木，两塔高度差为j时，最大的共同高度，那么答案就是dp[n][0]了。初始化dp[0][0]为0，其它为负无穷（都是不合法状态） 转移写了半天，最后自己都搞混了。自己定义的状态没有记清楚，搞得debug了半天。 思考 坑点： 没有。 技巧： 一定要记得自己状态代表的含义啊！！！×3\\times 3×3 H. 又见背包 题意 有(1≤n≤1001 \\leq n \\leq 1001≤n≤100)种大小不同的数字a_i,每种(1≤mi≤1091 \\leq m_i \\leq 10^91≤mi​≤109)个，判断是否可以从这些数字中选出若干使它们的和恰好为(1≤k≤1051 \\leq k \\leq 10^51≤k≤105)。 分析 诶！这不是男人八题？！多重背包 + 二进制优化 + bool型dp。 出题组说二进制优化会被卡！不管了，先写T了再说。结果AC，时间72ms。饿= =。 思考 坑点： 没有。 技巧： 使用bool型进行转移的话，比起平常调用max函数效率要快不少。另外，本题正解应该是多重背包的单调队列优化，复杂度O(V*N)。然而这种科技就留给fly和xf去吧，2333。 L. 来签个到吧 题意 初始有n个球，球上写着数字，第一阶段的任务是让任意两个球上数字之差都在这些球上出现（通过添加球办到），此阶段操作数固定，为放进球的个数；第二阶段需要任意从中抽出球，抽出后放回，直到所有数字都被拿出。问：两阶段的操作数期望值是多少？ 分析 第一阶段的任务就是把原始的数列变成等差数列，求公共gcd即可。 第二阶段要算期望了，默默想到一个状态，dp[i]代表拿到i张卡片的期望操作数，发现无法转移，GG。于是就上网查资料，发现了这个有趣的链接：传送 思考 坑点： 数列中的值存在0，此时不能把0考虑进入gcd。 技巧： 说好的dp呢？转移呢？怎么就变成解数学期望题了！！！把取到第i个数的平均次数相加就是期望次数，果然高中到现在，还是觉得概率啊，期望啊这种东西太迷了。 具体代码点击下方传送门:) 传送门 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/CQU-SCU-Union-Training-II-Dynamic-Programming/"},{"title":"CQU&SCU Union Training I - Searching and Strings","content":"前言 为期10天的第一次训练结束~ 时间好快。学到了好多知识~ 不过后缀数组还是不敢碰呀，算是这个专题的一个小遗憾吧。 A. 双剑合并 题意 从两个大小最大为1e6的数组中分别找出一个数，使得这两个数的异或和最大。 分析 1e6啊，暴力肯定不行了。把其中一个数组中的数字看成二进制，相当于是查找另一个数组中能把这个数中高位0位填了的数中效益最大的那个数。怎么查询呢？ 于是我试着二分查询补码，结果：GG。 思考 坑点： 无。 技巧： 将其中一个数组建立成trie树，然后另一个数组中的数在其中查询。注意：建树要从二进制位的高位往低位建树，查询同理。这样才能保证异或和最大。 B. 单词替换 题意 将一个长度最长为5e6的字符串中的单词A替换成单词B，输出替换后的字符串。 分析 单词替换，kmp匹配即可。 思考 坑点： 使用strlen多次计算长度，可能导致TLE。 技巧： 在kmp匹配的时候，当模式串匹配成功后，不用退出，接着匹配。一边匹配一边输出答案。 C. 01的时间 题意 输出不超过466的正整数由0和1构成的最小倍数。 分析 从1开始bfs，每次优先放0，接着放1，用char来存答案。 没有标记，直接MLE。 思考 坑点： 1)本题会爆long long，但是不会爆unsigned long long。2)bfs不标记会MLE。 技巧： 考虑一个很长的数字(长度&gt;100)，需要问这个数能否被某个数整除，我们可以直接从左往右解析这个数字，一边解析一边取模。本题可以借鉴这种做法，将模作为状态来标记，所以整个搜索空间最多466。每次取出数字优先添加0，之后添加1即可。 D. GooZy的游戏时间 题意 将小正方形进行平移，使得最终构成一个大正方形，并且两正方形邻接的三角形上数字相同。有解输出Possible，无解Impossible。最多25个小正方形。 分析 暴力查找 TLE 思考 坑点： 会出现24个全都相同的矩形，搜索空间爆炸。 技巧： 将相同的矩形预处理在一起，当前位置该矩形不行，那么其它所有和这个矩形一样的矩形也一定不能放在这个位置。 神之样例（还不知道怎么剪枝能过）&lt;由fly提供&gt;： 1 5 1 1 1 1 1 1 2 1 1 1 3 1 1 1 4 1 1 1 6 1 2 1 1 1 2 1 2 1 2 1 3 1 2 1 4 1 2 1 6 1 3 1 1 1 3 1 2 1 3 1 3 1 3 1 4 1 3 1 6 1 4 1 1 1 4 1 2 1 4 1 3 1 4 1 4 1 4 1 6 1 5 1 1 1 5 1 2 1 5 1 3 1 5 1 4 1 5 1 6 1 E. RunningPhoton's Nightmare 题意 在一个600×600600 \\times 600600×600的图中，需要从S点走到E点，但是有个计时器在计时，超过(≥k\\geq k≥k)就会爆炸，中间有R点，可以重置计时器时间为0，问能否走到E点？ 分析 bfs。结构体中存放当前的位置x和y，以及走了dis的时间，另开一个全局数组dis[i][j]记录到达点(i,j)炸弹的时间。每次向炸弹时间比该处小就能转移。 思考 坑点： 刚开始标程神之T++，算不算坑点，23333 技巧： 可以预处理起始点、终点、R点的最短距离，跑一遍最短路即可。（然而我没预处理直接bfs也过了= =。） F. 表达式 题意 初始只有x，可以用已有的值对当前值进行乘或者除，问：到达xnx^nxn需要的最少步骤是几步？(n≤1000)n \\leq 1000)n≤1000) 分析 贪心啊，每次倍增！嗯，就是这么搞。 结果是WA。 思考 坑点： 没有，953这个样例很友好地给了出来。 技巧： 迭代加深搜索，枚举深度。一个强力剪枝：当当前最大可能值在之后一直自乘，都无法到达n，就可以返回。 G. 神舟的宝藏 题意 用给定的进制和数，构成N的最小倍数。 分析 这不是进阶版的C题吗？ 思考 坑点： 无。 技巧： 抓住状态空间，用char数组存答案。其它同C题。 H. DNA序列 题意 构造一个DNA序列，使得其子序列能够组成给出的N个DAN序列中的任意一个。(N≤8,长度≤5N \\leq 8, 长度 \\leq 5N≤8,长度≤5) 分析 迭代加深试试。 剪枝不够强力T了。 思考 坑点： 剪枝不强，AAAAA，CCCCC，GGGGG，TTTTT这个样例是过不了的。 技巧： 首先，当某个串还差X才能构造出来，然而剩余深度小于X，那么可以肯定这之后就不用访问了，这是小剪枝。其次，用来构造的字符一定要是这N个串中所拥有的，否则加了白加，小剪枝。最后，每次统计所有串中，单串最长的A次数、C次数、G次数、T次数，他们的和就是需要构成的串至少需要的长度，这样倒着建立串，就能根据这个强力剪枝！ I. 小冰和小娜 题意 问：能否从起点到达终点，使得车轮的颜色起点和终点一样？能输出最少时间，否则-1。（车轮有五种颜色，每次转向或者前行消耗一个时间，移动一次变换一次颜色。） 分析 bfs，开四维数组记录到达点(x,y)方向为z，颜色为c所需要的最少时间。 思考 坑点： 转向和前行都得消耗时间。 技巧： 老老实实写BFS即可。 J. TooEasy Or TooDifficult 题意 求字符串最长回文串，求区间最大异或和。 分析 最长回文串easy，manacher即可。异或和没想法。 思考 坑点： MZ的次方数好可怕，以为不能用快速幂搞定Orz。 技巧： 区间异或和可以转换为从0开始区间连续的异或和，变成一个值，两个这样的值异或，就是它们的非公共区间异或和了。所以我们用trie来存异或值，这样就变成了求两个数的最大异或和，套用A题思路即可。 K. 奶牛合影 题意 求长度最大为3e5的环上，哪个点开始，字典序最小。 分析 典型的最小表示法呀。 思考 坑点： 无。 技巧： 会最小表示法就OK啦。 M. 奶牛硬盘 题意 用1000进位和1024进位来计算内存，所少计算的百分率是多少？最大到YB。 分析 数字相除，数字部分没用啊，那答案不就是固定的？来来来，打表。嗯，对了，特判0。 标程没有特判0，所以你特判就是错的。 思考 坑点： 标程错了= = 技巧： 不打表的话，只需每次记录下1000和1024的比率，根据单位乘就能得到结果了。 N. 奶牛情书 题意 给出不多于60个单词，长度不超过100，求至少包含其中一个单词，长度为M(M≤100M \\leq 100M≤100)的文本的构造方式有多少种？ 分析 好难= =。后来看挑战知道是字符串dp，需要自动机预处理。 没有考虑ABA CCCCCCABAC这种情况下，第二个字符串中包含了需要出现的串ABA，而我们的做法是：答案 = 所有可能情况 - 不可能情况，所以这里需要对fail数组处理一下。 思考 坑点： 串中还会包含串。 技巧： 用自动机预处理每个前缀能够到达的转移，在构建fail数组时，如果当前字符串的fail是禁止串，那么当前串也要标为禁止串。然后dp[i+1][nxt[j][k]]=dp[i][j]dp[i + 1][nxt[j][k]] = dp[i][j]dp[i+1][nxt[j][k]]=dp[i][j] ; (nxt[j][k]即：第j个前缀加上第k个字符后能够转移到的前缀) 具体代码点击下方传送门:) 传送门 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/CQU-SCU-Union-Training-I-Searching-and-Strings/"},{"title":"HDU 1824 Let's go home (2-SAT)","content":"题目链接： HDU 1824 Let's go home (2-SAT) 题意分析： n支队伍，m个关系。满足：1.队伍里面，队长和其余两名队员两者中必须有一个要留下来；2.关系中，A队员留下B队员就得离开，B队员留下，A队员就要离开。问：能否合理安排满足以上两个关系。 解题思路： 将每个点拆分成两种状态：留下和不留下，然后根据题目，设：A为队长，B和C为队员，那么就有!A-&gt;(B^C), (!Bv!C)-&gt;A, 然后每个关系中，有：B-&gt;!C, C-&gt;!B. 最终根据关系建边，判断矛盾关系是否在同一个连通分量内即可。 2-SAT类型的题，重要的就在于把这些对象间的关系理清楚。 个人感受： 这题充分考验了ACMer的语文水平，唉唉唉。 具体代码如下： #include&lt;algorithm&gt; #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iomanip&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;sstream&gt; #include&lt;stack&gt; #include&lt;string&gt; #define ll long long #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; '\\n'; using namespace std; const int INF = 0x7f7f7f7f; const int MAXN = 6e3 + 111; vector&lt;int&gt; G[MAXN]; int n, m; int dfn[MAXN], low[MAXN], sta[MAXN], id[MAXN], indx, scc, top; bool in[MAXN]; void init() { for (int i = 0; i &lt;= 6 * n; ++i) { G[i].clear(); in[i] = 0; dfn[i] = 0; } indx = scc = top = 0; } void tarjan(int u) { dfn[u] = low[u] = ++indx; sta[top++] = u; in[u] = 1; for (int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i]; if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if (in[v]) low[u] = min(low[u], dfn[v]); } if (dfn[u] == low[u]) { ++scc; int v; do { v = sta[--top]; in[v] = 0; id[v] = scc; } while (v != u); } } int main() { int a, b, c; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) { init(); int add = 3 * n; for (int i = 0; i &lt; n; ++i) { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); G[a + add].push_back(c); G[a + add].push_back(b); G[b + add].push_back(a); G[c + add].push_back(a); } int u, v; while (m --) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v + add); G[v].push_back(u + add); } for (int i = 0; i &lt; 6 * n; ++i) { if (!dfn[i]) tarjan(i); } bool flag = 1; for (int i = 0; i &lt; 3 * n; ++i) { if (id[i] == id[i + 3 * n]) { flag = 0; break; } } printf(&quot;%s\\n&quot;, flag? &quot;yes&quot; : &quot;no&quot;); } return 0; } 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/HDU-1824-Let-s-go-home-2-SAT/"},{"title":"HDU 3966 Aragorn's Story (树链剖分,线段树)","content":"题目链接： HDU 3966 Aragorn's Story (树链剖分,线段树) 题意分析： 有三种操作，操作I：增加一个区间中结点的值；操作D：减少一个区间中结点的值；操作Q：查询结点值。 解题思路： 将整棵树剖分成链，用线段树来维护。——树链剖分。 树链剖分巧妙地将同一条重链安排在了一起，这样变成一条总链的时候，只需要一条一条重链地更新或者查询就行了。具体还是建议上网找份PPT看。 个人感受： RE-&gt;WA-&gt;AC。RE应该是和lazy数组更新有关，后期WA是因为区间更新写错了。不过如今真得觉得线段树不难呀，以前要死要活的，哈哈 具体代码如下： #include&lt;algorithm&gt; #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iomanip&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;sstream&gt; #include&lt;stack&gt; #include&lt;string&gt; #define ll long long #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; '\\n'; using namespace std; const int INF = 0x7f7f7f7f; const int MAXN = 5e4 + 111; const int MAXM = 1e5 + 111; struct Edge { int to, next; }edge[MAXM]; int head[MAXN]; // 它们分别是：深度，重儿子，儿子数，链顶端，父亲节点，在数组中位置，位置代表的节点 int dep[MAXN], son[MAXN], num[MAXN], top[MAXN], fa[MAXN], p[MAXN], fp[MAXN]; int enemy[MAXN]; int pos, tol; void init(int n) { for (int i = 1; i &lt;= n; ++i) { son[i] = head[i] = -1; } pos = tol = 0; } void addedge(int u, int v) { edge[tol].to = v, edge[tol].next = head[u], head[u] = tol++; } void dfs1(int u, int pre, int d) { dep[u] = d; fa[u] = pre; num[u] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v != pre) { dfs1(v, u, d + 1); num[u] += num[v]; if (son[u] == -1 || num[son[u]] &lt; num[v]) { son[u] = v; } } } } void dfs2(int u, int f) { p[u] = ++pos; top[u] = f; fp[p[u]] = u; if (son[u] == -1) return; dfs2(son[u], f); for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v != son[u] &amp;&amp; v != fa[u]) dfs2(v, v); } } struct Node { int l, r, lazy; }st[MAXN &lt;&lt; 2]; void build(int l, int r, int rt) { st[rt].l = l; st[rt].r = r; st[rt].lazy = 0; if (l == r) { return; } int m = (l + r) &gt;&gt; 1; build(l, m, rt &lt;&lt; 1); build(m + 1, r, rt &lt;&lt; 1 | 1); } void pushdown(int rt) { if (st[rt].lazy != 0) { st[rt &lt;&lt; 1].lazy += st[rt].lazy; st[rt &lt;&lt; 1 | 1].lazy += st[rt].lazy; st[rt].lazy = 0; } } int query(int rt, int val) { if (st[rt].l == st[rt].r) return st[rt].lazy; pushdown(rt); int m = (st[rt].l + st[rt].r) &gt;&gt; 1; if (val &lt;= m) return query(rt &lt;&lt; 1, val); else return query(rt &lt;&lt; 1 | 1, val); } void update(int L, int R, int w, int rt) { int l = st[rt].l, r = st[rt].r; if (L &lt;= l &amp;&amp; r &lt;= R) { st[rt].lazy += w; return; } pushdown(rt); int m = (l + r) &gt;&gt; 1; if (L &lt;= m) update(L, R, w, rt &lt;&lt; 1); if (m &lt; R) update(L, R, w, rt &lt;&lt; 1 | 1); } void change(int u, int v, int w) { while (top[u] != top[v]) { // 慢慢向重链靠近 if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); update(p[top[u]], p[u], w, 1); u = fa[top[u]]; } if (dep[u] &gt; dep[v]) swap(u, v); update(p[u], p[v], w, 1); } int main() { int n, m, q, u, v, w; while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q)) { init(n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;enemy[i]); for (int i = 0; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); addedge(u, v); addedge(v, u); } dfs1(1, 0, 0); dfs2(1, 1); build(1, pos, 1); char op[2]; while (q--) { scanf(&quot;%s&quot;, op); if (op[0] == 'Q') { scanf(&quot;%d&quot;, &amp;u); printf(&quot;%d\\n&quot;, enemy[u] + query(1, p[u])); } else { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); if (op[0] == 'D') w = -w; change(u, v, w); } } } return 0; } 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/HDU-3966-Aragorn-s-Story-树链剖分-线段树/"},{"title":"ZJU 1008 Gnome Tetravex (DFS)","content":"题目链接： ZJU 1008 Gnome Tetravex (DFS) 题意分析： 给出N×NN \\times NN×N块正方形，每一块被切割成上下左右四个三角形，每个三角形写上0~9的值，问：能否移动这些正方形的位置，使得它们排列成N×NN \\times NN×N的方块，每一个相邻的边上数字都相同。 解题思路： 从第一个方块开始枚举，还必须加上必要的剪枝，比如规格相同的方块在同一个地方不可行一次就不用试第二次了。 个人感受： 啊啊啊，剪枝想不到啊啊啊啊啊。。。 具体代码如下： #include&lt;algorithm&gt; #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iomanip&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;sstream&gt; #include&lt;stack&gt; #include&lt;string&gt; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; '\\n'; using namespace std; struct Square { int u, r, d, l; }sq[30]; int mp[10][10], sum[30]; int n, ed; bool dfs(int p) { if (p == ed) { return 1; } int x = p / n, y = p % n; for (int i = 0; i &lt; ed; ++i) { if (!sum[i]) continue; if (x &gt; 0 &amp;&amp; sq[mp[x - 1][y]].d != sq[i].u) continue; if (y &gt; 0 &amp;&amp; sq[mp[x][y - 1]].r != sq[i].l) continue; mp[x][y] = i; --sum[i]; if (dfs(p + 1)) return 1; ++sum[i]; } return 0; } int main() { int kase = 0; while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) { ed = n * n; for (int i = 0; i &lt; ed; ++i) { sum[i] = 0; scanf(&quot;%d%d%d%d&quot;, &amp;sq[i].u, &amp;sq[i].r, &amp;sq[i].d, &amp;sq[i].l); bool flag = 1; for (int j = 0; j &lt; i; ++j) { if (sq[i].u == sq[j].u &amp;&amp; sq[i].r == sq[j].r &amp;&amp; sq[i].d == sq[j].d &amp;&amp; sq[i].l == sq[j].l) { ++sum[j]; flag = 0; break; } } if (flag) sum[i] = 1; } if (kase) putchar('\\n'); if (dfs(0)) printf(&quot;Game %d: Possible\\n&quot;, ++kase); else printf(&quot;Game %d: Impossible\\n&quot;, ++kase); } return 0; } 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/ZJU-1008-Gnome-Tetravex-dfs/"},{"title":"POJ 2763 Housewife Wind (LCA,RMQ,BIT)","content":"题目链接： POJ 2763 Housewife Wind (LCA,RMQ,BIT) 题意分析： 给出两个操作，0：妈妈需要到树上某个结点接孩子，每次输出最短距离，然后妈妈的位置变成孩子所在的位置。1：更改树上某条边的距离为w。 解题思路： 由于每次移动都会使得母亲的位置变动，这里我们需要使用LCA的在线算法。 首先，我们将整棵树根据后序遍历拉成一条链，每次记录这个链上结点代表的结点是什么(vs[i])和深度是多少(dep[i])，顺便记录这个结点第一次出现的时候是在链上什么位置(id[i])。然后每次lca(a,b)lca(a,b)lca(a,b)其实就是查询[id[a],id[b]][id[a],id[b]][id[a],id[b]]这个区间内，dep最小的那个下标是什么。 其次，由于本题涉及到更新操作，如上我们已经把它拉成一条链了，所以下一步只需在父亲指向儿子的边加权值，儿子指向父亲的边减权值，然后查询区间$$sum(id[a])+sum(id[b])-2 \\times sum(id[lca(a,b)])$$即可。 个人感受： 爽呆了这题，为了A这题，A了两道RMQ，复习了BIT，爽23333 具体代码如下： #include&lt;algorithm&gt; #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iomanip&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;sstream&gt; #include&lt;stack&gt; #include&lt;string&gt; using namespace std; const int MAXN = 1e5 + 111; struct Edge { int to, id, w, next; }edge[MAXN * 2]; int head[MAXN], tol; void addedge(int u, int v, int id, int w) { edge[tol].to = v; edge[tol].w = w; edge[tol].id = id; edge[tol].next = head[u]; head[u] = tol++; } int s, bitn; int w[MAXN]; vector&lt;Edge&gt; G[MAXN]; int id[MAXN], es[MAXN * 2], dep[MAXN * 2], vs[MAXN * 2]; int bit[MAXN * 2], dp[MAXN * 2][20]; void add(int i, int x) { while (i &lt;= bitn) { bit[i] += x; i += lowbit(i); } } int sum(int i) { int ret = 0; while (i &gt; 0) { ret += bit[i]; i -= lowbit(i); } return ret; } void dfs(int u, int p, int sum, int &amp;k) { id[u] = k; vs[k] = u; dep[k++] = sum; for (int i = head[u]; ~i; i = edge[i].next) { Edge &amp;e = edge[i]; if (e.to != p) { add(k, e.w); es[e.id * 2] = k; dfs(e.to, u, sum + e.w, k); vs[k] = u; dep[k++] = sum; add(k, -e.w); es[e.id * 2 + 1] = k; } } } int my_min(int a, int b) { return dep[a] &lt;= dep[b] ? a : b; } void init_rmq(int n) { for (int i = 0; i &lt;= n; ++i) dp[i][0] = i; for (int j = 1; j &lt; 20; ++j) { for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) { dp[i][j] = my_min(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); } } } void init(int n) { bitn = n * 2 - 1; memset(bit, 0, sizeof bit); int k = 0; dfs(0, -1, 0, k); init_rmq(2 * n - 1); } int query(int l, int r) { int k = log2(r - l + 1); return my_min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]); } int lca(int a, int b) { if (id[a] &gt; id[b]) swap(a, b); return vs[query(id[a], id[b])]; } int main() { int n, q, u, v; while (~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;q, &amp;s)) { for (int i = 0; i &lt; n; ++i) G[i].clear(), head[i] = -1; tol = 0; for (int i = 0; i &lt; n - 1; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w[i]); --u, --v; addedge(u, v, i, w[i]); addedge(v, u, i, w[i]); } init(n); int op, a, b; --s; for (int i = 0; i &lt; q; ++i) { scanf(&quot;%d%d&quot;, &amp;op, &amp;a); --a; if (op == 0) { int p = lca(s, a); printf(&quot;%d\\n&quot;, sum(id[s]) + sum(id[a]) - 2 * sum(id[p])); s = a; } else { scanf(&quot;%d&quot;, &amp;b); add(es[2 * a], b - w[a]); add(es[2 * a + 1], w[a] - b); w[a] = b; } } } return 0; } 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/POJ-2763-Housewife-Wind-LCA-RMQ-BIT/"},{"title":"POJ 1426 Find The Multiple (BFS)","content":"题目链接： POJ 1426 Find The Multiple (BFS) 题意分析： 给出一个数字n，查找一个只由0和1构成的数字，使得这个数字能够整除n。输出一个这样的数字。 解题思路： 首先第一个数肯定是1，然后不断得枚举添加0或者1，用BFS进行搜索即可。这里要注意两点： 1.长度很大的数字取余数可以使用从左到右解析的方式，所以每一次我们保留下解析后的余数即可，然后使用余数作为标记。 2.这就要求我们需要另开一个数组来存答案，所以BFS里面存的是结构体。 个人感受： 不知道POJ上面那些肯定long long能存的下的人结论是哪里来的。想到了余数计算就行，却没想到怎么标记，加油~ 具体代码如下： #include&lt;algorithm&gt; #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iomanip&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;sstream&gt; #include&lt;stack&gt; #include&lt;string&gt; #define lowbit(x) (x &amp; (-x)) #define ll long long #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; '\\n'; using namespace std; struct P { char ans[111]; int cnt; int mod; }; bool vis[311]; int main() { int n; while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) { queue&lt;P&gt; q; memset(vis, 0, sizeof vis); P st; st.cnt = 1; st.ans[0] = '1'; st.mod = 1 % n; q.push(st); while (q.size()) { P cur = q.front(); q.pop(); if (cur.mod == 0) { for (int i = 0; i &lt; cur.cnt; ++i) printf(&quot;%c&quot;, cur.ans[i]); putchar('\\n'); break; } vis[cur.mod] = 1; cur.cnt = cur.cnt + 1; cur.ans[cur.cnt - 1] = '0'; cur.mod = (cur.mod * 10) % n; if (!vis[cur.mod]) q.push(cur); cur.ans[cur.cnt - 1] = '1'; cur.mod = (cur.mod + 1) % n; if (!vis[cur.mod]) q.push(cur); } } return 0; } 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/POJ-1426-Find-The-Multiple-BFS/"},{"title":"POJ 3264 Balanced Lineup (RMQ,ST)","content":"题目链接： POJ 3264 Balanced Lineup (RMQ,ST) 题意分析： 询问区间[L,R][L,R][L,R]最大值和最小值的差值为多少? 解题思路： RMQ的ST算法登场。dpl[i][j]dpl[i][j]dpl[i][j]代表：从第i个数开始，包含第i个数，区间长度为2j2^j2j范围内的最小值。有转移：$$dpl[i][j] = min(dp[i][j - 1], dp[i + 2^{j - 1}][j - 1])$$ dph[i][j]dph[i][j]dph[i][j]同理。 最终求区间中的最小值，那么我们只需查询: k=log2(r−l+1)k = log_2(r - l + 1)k=log2​(r−l+1) ans=min(dpl[i][k],dpl[i+(1&lt;&lt;k)+1][k])ans = min(dpl[i][k], dpl[i + (1 &lt;&lt; k) + 1][k])ans=min(dpl[i][k],dpl[i+(1&lt;&lt;k)+1][k]) 个人感受： 头一次写ST算法，原来也不难啊......以前以为很复杂Orz 具体代码如下： #include&lt;algorithm&gt; #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iomanip&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;sstream&gt; #include&lt;stack&gt; #include&lt;string&gt; #define lowbit(x) (x &amp; (-x)) #define ll long long #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; '\\n'; using namespace std; const int INF = 0x7f7f7f7f; const int MAXN = 5e4 + 111; int dpl[MAXN][20], dph[MAXN][20], a[MAXN]; int getMax(int l, int r) { int k = log2(r - l + 1); return max(dph[l][k], dph[r - (1 &lt;&lt; k) + 1][k]); } int getMin(int l, int r) { int k = log2(r - l + 1); return min(dpl[l][k], dpl[r - (1 &lt;&lt; k) + 1][k]); } int main() { int n, q; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;q)) { for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i]); dpl[i][0] = dph[i][0] = a[i]; } for (int j = 1; j &lt; 20; ++j) { for (int i = 1; i &lt;= n; ++i) { if (i + (1 &lt;&lt; j) - 1 &lt;= n) { dpl[i][j] = min(dpl[i][j - 1], dpl[i + (1 &lt;&lt; (j - 1))][j - 1]); dph[i][j] = max(dph[i][j - 1], dph[i + (1 &lt;&lt; (j - 1))][j - 1]); } else break; } } int l, r; for (int i = 0; i &lt; q; ++i) { scanf(&quot;%d%d&quot;, &amp;l, &amp;r); printf(&quot;%d\\n&quot;, getMax(l, r) - getMin(l, r)); } } return 0; } 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/POJ-3264-Balanced-Lineup-RMQ-ST/"},{"title":"ZJU 2760 How Many Shortest Path (最大流)","content":"题目链接：ZJU 2760 How Many Shortest Path (最大流) 题意分析： 求从指定点到指定点的没有重边的最短路个数。如果起点终点相同，则输出“inf”。 解题思路： 将最短路上的所有边都保留下来，求最大流即可。注意：本题i == j 时，不一定矩阵就是0，坑爹啊。 个人感受： 首先是我一直以为流量为0输出inf，没想到这样判断就T成傻逼。。。。。还以为是floyd的锅！通过此，又对自己的板子加深了理解XD。mp[i][i]不一定为0也是醉了。 具体代码如下： #include&lt;algorithm&gt; #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iomanip&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;sstream&gt; #include&lt;stack&gt; #include&lt;string&gt; #define lowbit(x) (x &amp; (-x)) #define ll long long #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; '\\n'; using namespace std; const int MAXN = 210;//点数的最大值 const int MAXM = 20000;//边数的最大值 const int INF = 0x3f3f3f3f; struct Edge { int to,next,cap,flow; }edge[MAXM];//注意是MAXM int tol, src, des; int head[MAXN]; int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN]; void init() { tol = 0; memset(head,-1,sizeof(head)); } //加边，单向图三个参数，双向图四个参数 void addedge(int u,int v,int w,int rw=0) { edge[tol].to = v;edge[tol].cap = w;edge[tol].next = head[u]; edge[tol].flow = 0;head[u] = tol++; edge[tol].to = u;edge[tol].cap = rw;edge[tol].next = head[v]; edge[tol].flow = 0;head[v]=tol++; } //输入参数：起点、终点、点的总数 //点的编号没有影响，只要输入点的总数 int sap(int start,int end,int N) { memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u = start; pre[u] = -1; gap[0] = N; int ans = 0; while(dep[start] &lt; N) { if(u == end) { int Min = INF; for(int i = pre[u];i != -1; i = pre[edge[i^1].to]) if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; for(int i = pre[u];i != -1; i = pre[edge[i^1].to]) { edge[i].flow += Min; edge[i^1].flow -= Min; } u = start; ans += Min; continue; } bool flag = false; int v; for(int i = cur[u]; i != -1;i = edge[i].next) { v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]) { flag = true; cur[u] = pre[v] = i; break; } } if(flag) { u = v; continue; } int Min = N; for(int i = head[u]; i != -1;i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) { Min = dep[edge[i].to]; cur[u] = i; } gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min+1; gap[dep[u]]++; if(u != start) u = edge[pre[u]^1].to; } return ans; } int mp[MAXN][MAXN], dp[MAXN][MAXN]; void floyd(int n) { for (int k = 0; k &lt; n; ++k) { for (int i = 0; i &lt; n; ++i) { if (dp[i][k] == INF) continue; for (int j = 0; j &lt; n; ++j) { if (dp[k][j] == INF) continue; dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]); } } } } int main() { int n; while (~scanf(&quot;%d&quot;, &amp;n)) { init(); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; n; ++j) { scanf(&quot;%d&quot;, &amp;mp[i][j]); if (i == j) mp[i][j] = 0; dp[i][j] = mp[i][j]; if (mp[i][j] == -1) dp[i][j] = INF; } } scanf(&quot;%d%d&quot;, &amp;src, &amp;des); floyd(n); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; n; ++j) { if (mp[i][j] == -1) continue; if (dp[src][des] == dp[src][i] + mp[i][j] + dp[j][des]) { addedge(i, j, 1); } } } if (src == des) printf(&quot;inf\\n&quot;); else printf(&quot;%d\\n&quot;, sap(src, des, n)); } return 0; } 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/ZJU-2760-How-Many-Shortest-Path-最大流/"},{"title":"UESTC 92 Journey (离线LCA)","content":"题目链接：UESTC 92 Journey (离线LCA) 题意分析： 给出一棵树和一条边，问加上这条边后，对于每一个查询，能优化多少的距离？ 解题思路： 这题多了一条边，那么我们只需要在查询的时候，特别考虑这条边存在的情况对原条件的影响即可。具体就是： 设新边为xy，费用w，查询的点为u和v，令dis(u,v)dis(u,v)dis(u,v)为点u和点v的树上最短距离，那么考虑新边之后，多出了两个路径，一：dis(u,x)+dis(y,v)+wdis(u,x) + dis(y,v) + wdis(u,x)+dis(y,v)+w；二：dis(u,y)+dis(x,v)+wdis(u,y) + dis(x,v) + wdis(u,y)+dis(x,v)+w；然后根据题意来搞就行了:) 个人感受： 哦~我的第一想法是做两次tarjan，但是这样第二次加了新边做会放弃某条边，GG。其实我觉得缩点也是可以的，哈哈，不过我自己都嫌他麻烦。 具体代码如下： #include&lt;algorithm&gt; #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iomanip&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;sstream&gt; #include&lt;stack&gt; #include&lt;string&gt; #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; '\\n'; using namespace std; const int INF = 0x7f7f7f7f; const int MAXN = 1e5 + 111; struct Edge { int next, to, w; }edge[MAXN * 2]; struct Query { int next, to, ans; }query[MAXN * 10]; int head[MAXN], qhead[MAXN], tol, qtol; int dep[MAXN], par[MAXN]; bool vis[MAXN]; int find(int x) { return x == par[x] ? x : par[x] = find(par[x]); } void init() { tol = qtol = 0; memset(head, -1, sizeof head); memset(qhead, -1, sizeof qhead); memset(vis, 0, sizeof vis); } void addedge(int u, int v, int w) { edge[tol].to = v; edge[tol].next = head[u]; edge[tol].w = w; head[u] = tol++; } void qaddedge(int u, int v) { query[qtol].to = v; query[qtol].next = qhead[u]; qhead[u] = qtol++; query[qtol].to = u; query[qtol].next = qhead[v]; qhead[v] = qtol++; } void tarjan(int u, int sum) { dep[u] = sum; par[u] = u; vis[u] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (!vis[v]) { tarjan(v, sum + edge[i].w); par[v] = u; } } for (int i = qhead[u]; ~i; i = query[i].next) { int v = query[i].to; if (vis[v]) { query[i^1].ans = query[i].ans = dep[u] + dep[v] - 2 * dep[par[find(v)]]; } } } int main() { int t; scanf(&quot;%d&quot;, &amp;t); int kase = 0; while (t --) { init(); int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int u, v, w; int u1, v1, w1; for (int i = 0; i &lt; n - 1; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); } scanf(&quot;%d%d%d&quot;, &amp;u1, &amp;v1, &amp;w1); for (int i = 0; i &lt; m; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); qaddedge(u, v); qaddedge(u, u1); qaddedge(v, v1); qaddedge(u, v1); qaddedge(v, u1); } tarjan(1, 0); printf(&quot;Case #%d:\\n&quot;, ++kase); for (int i = 0; i &lt; qtol; i += 10) { int disuv = query[i].ans; int disuu1 = query[i + 2].ans; int disvv1 = query[i + 4].ans; int disuv1 = query[i + 6].ans; int disvu1 = query[i + 8].ans; int mi = min(disuu1 + disvv1 + w1, disuv1 + w1 + disvu1); printf(&quot;%d\\n&quot;, disuv - min(disuv, mi)); } } return 0; } 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/UESTC-92-Journey-离线LCA/"},{"title":"建站小记","content":"写在前面 昨晚折腾到了凌晨4点，总算是收尾了，祝贺下~这篇也不打算讲具体如何建站，这类教程网上都是。所以打算总结下这期间比较让我费时的事情。 推荐一个hexo主题：NexT 1.NexT很简洁，本站就是采用了NexT提供的三种主题中的NexT.Pisces 2.官方教程十分详细，基本按着教程来，80%的问题都是能解决的。附地址：点我 3.当然，一切的前提是你已经部署好了博客XD 关于Favicon 官方说把ico图标命名为favicon.ico放到站点配置的source目录下即可，但是我的并不行，需要把图标放在themes/next/source下才可行 推荐布置博客方法 在github上的仓库中建立两个分支，其中master分支存放hexo生成的站点，另一个分支用于存放站点部署文件，也就是本地的那个文件。这样就不用担心换了电脑还得随身带着本地部署这种事情了。 具体参考此人博客：点我 有几点需要注意： 1.记得把分支设为默认分支，具体在仓库页面的setting中设置,否则会使得push到本地仓库的是master。 2.上传到git的部署文件不会将主题文件同步上去，因为主题本身是个仓库，网上说只需把主题里面的**.git**删除即可。然而对我没什么用，所以目前我是打算将来更新直接自己手动备份主题...... Update: 删除github上分支里的themes文件夹，然后删除本地next里面的.git文件，重新上传到github就能同步备份了。 如何为文章分配到子分类 具体的说法就是，比如某篇文章属于**“生活”分类下的“日志”**分类。那么只需在文章头添加 categories: [生活,日志] 最终会生成分类信息： - 生活(1) - 日志(1) 顺便一提：多个书签也是同样的方法并排书写即可。 最后呢，推荐一款windows下的本地markdown编辑器 地址来啦：免费哦，开源哦~ 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/建站小记/"},{"title":"POJ 1986 Distance Queries (LCA)","content":"题目链接：POJ 1986 Distance Queries (LCA) 题意分析： 求树上两点间的最短距离。 解题思路： 典型的离线LCA啊，主要是涉及到上一题的条件输入。不过本题边的朝向并不影响解题:) 个人感受： 时间主要废在看这题和上题题目上了2333 具体代码如下： #include&lt;algorithm&gt; #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iomanip&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;sstream&gt; #include&lt;stack&gt; #include&lt;string&gt; #define ll long long #define pr(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; '\\n'; using namespace std; const int INF = 0x7f7f7f7f; const int MAXN = 4e4 + 111; const int MAXM = 8e4 + 222; struct Edge { int to, w, next; }edge[MAXM]; int head[MAXN], tol; struct Query { int to, id, next; }query[MAXM]; int qhead[MAXN], qtol, ans[MAXN], dis[MAXN]; bool vis[MAXN]; int par[MAXN]; int find(int x) { return par[x] == x ? x : par[x] = find(par[x]); } void init() { tol = qtol = 0; memset(head, -1, sizeof head); memset(qhead, -1, sizeof qhead); } void addedge(int u, int v, int w) { edge[tol].to = v; edge[tol].w = w; edge[tol].next = head[u]; head[u] = tol++; } void qaddedge(int u, int v, int id) { query[qtol].to = v; query[qtol].id = id; query[qtol].next = qhead[u]; qhead[u] = qtol++; } void dfs(int u, int sum) { dis[u] = sum; vis[u] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (!vis[v]) { dfs(v, sum + edge[i].w); } } } void tarjan(int u) { par[u] = u; vis[u] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (vis[v]) continue; tarjan(v); par[v] = u; } for (int i = qhead[u]; ~i; i = query[i].next) { int v = query[i].to; if (vis[v]) { ans[query[i].id] = dis[u] + dis[v] - 2 * dis[find(par[v])]; } } } int main() { #ifdef LOCAL freopen(&quot;C:\\\\Users\\\\apple\\\\Desktop\\\\in.txt&quot;, &quot;r&quot;, stdin); #endif int n, m; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) { int u, v, w, k; init(); char s[2]; for (int i = 0; i &lt; m; ++i) { scanf(&quot;%d%d%d%s&quot;, &amp;u, &amp;v, &amp;w, s); addedge(u, v, w); addedge(v, u, w); } scanf(&quot;%d&quot;, &amp;k); for (int i = 0; i &lt; k; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); qaddedge(u, v, i); qaddedge(v, u, i); } memset(vis, 0, sizeof vis); dfs(1, 0); memset(vis, 0, sizeof vis); tarjan(1); for (int i = 0; i &lt; k; ++i) { printf(&quot;%d\\n&quot;, ans[i]); } } return 0; } 广告时间 Java学习网站: VPS: ","link":"https://goozy.github.io/post/POJ-1986-Distance-Queries-LCA/"}]}